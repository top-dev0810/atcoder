#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < (n); ++i)
using ll = long long;

class UnionFind
{
public:
    std::vector<int> parent; // parent[i] は要素 i の親を表す
    std::vector<int> sz;     // sz[i] は i が根である場合の集合のサイズを表す

    // コンストラクタ
    // n: 管理する要素の数（0から n-1 まで）
    UnionFind(int n)
    {
        parent.resize(n);
        std::iota(parent.begin(), parent.end(), 0); // 最初は各要素が自分自身を親とする
        sz.assign(n, 1);                            // 最初は各集合のサイズは1
    }

    // 要素 x が属する集合の代表元（根）を探す
    // 経路圧縮
    int find(int x)
    {
        if (parent[x] == x)
        {
            return x;
        }
        return parent[x] = find(parent[x]);
    }

    // 要素 x が属する集合と要素 y が属する集合を併合する
    // Union by Size
    // 併合が成功したら true, 既に同じ集合に属していたら false を返す
    bool unite(int x, int y)
    {
        int root_x = find(x);
        int root_y = find(y);

        if (root_x == root_y)
        { // 既に同じ集合に属している
            return false;
        }

        if (sz[root_x] < sz[root_y])
        {
            std::swap(root_x, root_y);
        }

        parent[root_y] = root_x;
        sz[root_x] += sz[root_y];

        return true;
    }

    // 要素 x と要素 y が同じ集合に属するか判定する
    bool same(int x, int y)
    {
        return find(x) == find(y);
    }

    // 要素 x が属する集合のサイズを返す
    int size(int x)
    {
        return sz[find(x)];
    }
};

int main()
{
    int n, m;
    cin >> n >> m;
    vector<int> deg(n);
    UnionFind uf(n);
    rep(i, m)
    {
        int a, b;
        cin >> a >> b;
        a--;
        b--;
        deg[a]++;
        deg[b]++;
        uf.unite(a, b);
    }
    if (deg == vector<int>(n, 2) && uf.size(0) == n)
    {
        cout << "Yes" << endl;
    }
    else
    {
        cout << "No" << endl;
    }
}
