#include<bits/stdc++.h>
using ll = long long;
using ull = unsigned long long;
#define pll pair<ll,ll>
#define vll vector<ll>
#define vull vector<ull>
#define vpll vector<pll>
#define mii map<int,int>
#define mll map<ll,ll>
#define si set<int>
#define sll set<ll>
#define pv(v) for(int _ = 0;_<v.size();++_) {cout << v[_] << " ";} cout << endl;
#define pvr(v,a,b) for(int _ = a;_<b;++_) {cout << v[_] << " ";}
#define iv(v,n) for(int _ = 0;_<n;++_){cin >> v[_];}
#define all(x) (x).begin(),(x).end()
const ll P1 = 1000000007;
const ll P2 = 998244353;
#define ret return;

using namespace std;

void FAST() {	/*FAST Input Output, DONT use both scanf,printf - cin,cout , Use any ONE system*/
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
}

int find_set(int v,vll &parent) {
    if (v == parent[v])
        return v;
    return parent[v] = find_set(parent[v],parent);
}

void make_set(int v,vll &parent,vll &rank) {
    parent[v] = v;
    rank[v] = 0;
}

void union_sets(int a, int b,vll &parent,vll &rank) {
    a = find_set(a,parent);
    b = find_set(b,parent);
    if (a != b) {
        if (rank[a] < rank[b])
            swap(a, b);
        parent[b] = a;
        if (rank[a] == rank[b])
            rank[a]++;
    }
}

inline void ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !std::isspace(ch);
    }));
}

inline void rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
    }).base(), s.end());
}
/* Pseudocode for Binary Search
L = 0, R = N-1
while L <= R:
    mid = L + (R-L)/2
    if arr[mid] == target: 
        return mid
    if arr[mid] < target:
        L = mid+1
    else:
        R = mid-1
*/

map<long long, long long> factorize(long long n) {	//returns map containing
//factor and multiplicity, Eg: 60 = {{2,2},{3,1},{5,1}}
    map<long long, long long> ans;
    for (long long i = 2; i * i <= n; i++) {
        while (n % i == 0) {
            ans[i]++;
            n /= i;
        }
    }
    if (n > 1) {
        ans[n]++;
        n = 1;
    }
    return ans;
}
ll binpow(ll a,ll b,ll m){
    if(b==0) return 1;
    else if(b%2){
        ll t= binpow(a,b>>1,m);
        t = (1ll*t*t)%m;
        return (1ll*a*t)%m;
    }
    else{
        ll t= binpow(a,b>>1,m);
        return (1ll*t*t)%m;
    }
}

ll inv(ll b,ll m){
    return binpow(b,m-2,m);
}
void eratsieveOPT(vector<bool> & v){
    v[0] = v[1] = false;
    for(int i= 2 ;i<=v.size();++i){
        if(v[i]){
            for(int j = i*i;j<=v.size();j+=i){
                v[j] = false;
            }
        }
    }
}
vector<bool> sieve(1e5+1,true);
void solve(){

    return ;
}

void dfs(int v, vector<vector<int>> & ad, vector<int>& c, int cn){
    if(c[v]!=0) return;
    c[v] = cn;
    for(auto vert: ad[v]) dfs(vert,ad,c,cn);
}
int main(){
    bool ans = true;
    int n,m;
    cin >> n >> m;
    ans &= (n == m);
    vector<vector<int>> ad(n+1);
    for(int i = 0;i<m;++i){
        int a,b;
        cin >> a >> b;
        ad[a].push_back(b);
        ad[b].push_back(a);
        if(ad[a].size()>2 || ad[b].size()>2) ans = false;
    }
    vector<int> comp(n+1,0);
    int cn = 1;
    for(int i = 1;i<=n;++i){
        dfs(i,ad,comp,cn);
        cn++;
    }
    for(int i = 1;i<=n;++i){
        ans &= (comp[i] == 1);
    }
    if(!ans) cout << "No\n"; 
    else cout << "Yes\n";
    return 0;
}