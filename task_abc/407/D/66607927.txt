#include <bits/stdc++.h>
#define fastIO                                                                 \
  ios_base::sync_with_stdio(false);                                            \
  cin.tie(nullptr)
using namespace std;
template <class T> inline bool chmax(T &a, T b) {
  if (a < b) {
    a = b;
    return true;
  }
  return false;
}
template <class T> inline bool chmin(T &a, T b) {
  if (a > b) {
    a = b;
    return true;
  }
  return false;
}
#pragma GCC optimize("O3,unroll-loops")
#define ll long long
#define ld long double
#define pii pair<ll, ll>
#define mp make_pair
#define f first
#define s second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define rep(i, a, b) for (int i = a; i < b; i++)
const ll INF = 1000000000000000000;
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0, -1};
string stepDir = "URDL";

/******** Debug Code *******/
void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char *x) { cerr << '\"' << x << '\"'; }
void __print(const string &x) { cerr << '\"' << x << '\"'; }
void __print(bool x) { cerr << (x ? "true" : "false"); }
template <typename A> void __print(const A &x);
template <typename A, typename B> void __print(const pair<A, B> &p);
template <typename... A> void __print(const tuple<A...> &t);
template <typename T> void __print(stack<T> s);
template <typename T> void __print(queue<T> q);
template <typename T, typename... U> void __print(priority_queue<T, U...> q);
template <typename A> void __print(const A &x) {
  bool first = true;
  cerr << '{';
  for (const auto &i : x) {
    cerr << (first ? "" : ","), __print(i);
    first = false;
  }
  cerr << '}';
}
template <typename A, typename B> void __print(const pair<A, B> &p) {
  cerr << '(';
  __print(p.first);
  cerr << ',';
  __print(p.second);
  cerr << ')';
}
template <typename... A> void __print(const tuple<A...> &t) {
  bool first = true;
  cerr << '(';
  apply(
      [&first](const auto &...args) {
        ((cerr << (first ? "" : ","), __print(args), first = false), ...);
      },
      t);
  cerr << ')';
}
template <typename T> void __print(stack<T> s) {
  vector<T> debugVector;
  while (!s.empty()) {
    T t = s.top();
    debugVector.push_back(t);
    s.pop();
  }
  reverse(debugVector.begin(), debugVector.end());
  __print(debugVector);
}
template <typename T> void __print(queue<T> q) {
  vector<T> debugVector;
  while (!q.empty()) {
    T t = q.front();
    debugVector.push_back(t);
    q.pop();
  }
  __print(debugVector);
}
template <typename T, typename... U> void __print(priority_queue<T, U...> q) {
  vector<T> debugVector;
  while (!q.empty()) {
    T t = q.top();
    debugVector.push_back(t);
    q.pop();
  }
  __print(debugVector);
}
void _print() { cerr << "]\n"; }
template <typename Head, typename... Tail>
void _print(const Head &H, const Tail &...T) {
  __print(H);
  if (sizeof...(T))
    cerr << ", ";
  _print(T...);
}
#ifndef ONLINE_JUDGE
#define dbg(...)                                                               \
  cerr << "Line:" << __LINE__ << " [" << #__VA_ARGS__ << "] = [";              \
  _print(__VA_ARGS__)
#else
#define dbg(...)
#endif

#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;

template <class T>
using Tree =
    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T> using min_pq = priority_queue<T, vector<T>, greater<T>>;
template <typename T> using max_pq = priority_queue<T>;

int main() {
  fastIO;
  cout << fixed << setprecision(10);
  int n, m;
  cin >> n >> m;
  vector a(n, vector<ll>(m));
  for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++) {
      cin >> a[i][j];
    }
  vector covered(n, vector<bool>(m, false));
  ll ans = 0;
  auto dfs = [&](auto &dfs, int i, int j, ll x) -> void {
    if (i == n) {
      ans = max(ans, x);
      return;
    }
    if (j == m) {
      dfs(dfs, i + 1, 0, x);
      return;
    }
    if (covered[i][j]) {
      dfs(dfs, i, j + 1, x);
      return;
    }
    dfs(dfs, i, j + 1, x ^ a[i][j]); // skip
    if (!covered[i][j]) {
      // horz
      if (j + 1 < m && !covered[i][j + 1]) {
        covered[i][j] = true;
        covered[i][j + 1] = true;
        dfs(dfs, i, j + 2, x);
        covered[i][j] = false;
        covered[i][j + 1] = false;
      }
      // vert
      if (i + 1 < n && !covered[i + 1][j]) {
        covered[i][j] = true;
        covered[i + 1][j] = true;
        dfs(dfs, i, j + 1, x);
        covered[i][j] = false;
        covered[i + 1][j] = false;
      }
    }
  };

  dfs(dfs, 0, 0, 0);
  cout << ans;
}
