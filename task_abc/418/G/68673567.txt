#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    string s;
    if (!(cin >> N))
        return 0;
    cin >> s;
    const int n = (int)s.size();

    // -------- Common aggregates (single forward pass) --------
    long long TOT = 1LL * n * (n + 1) / 2;

    long long cnt1 = 0, cnt0 = 0;
    long long sumPos1_1 = 0; // sum of (index+1) over '1'
    int first1 = -1, last1 = -1;

    long long sumAllOneSubs = 0;  // sum of lengths over consecutive '1' runs
    long long sumAllZeroSubs = 0; // sum of lengths over consecutive '0' runs
    int run1 = 0, run0 = 0, maxRun1 = 0;

    long long cnt01 = 0, cnt10 = 0, cnt11 = 0;
    long long cnt000 = 0, cnt101 = 0, cnt111 = 0;

    // For 0100 / 1101
    long long M0100 = 0,
              M1101 =
                  0; // M0100: len>=2 分のみ。最後に +cnt1 して単文字'1'を足す
    int L0100 = -1;
    int lastZeroIdx = 0; // 1-indexed position of last '0' up to previous j
    int lastOneIdx = 0;  // 1-indexed position of last '1' up to previous j
    int secondLastOneIdx =
        0; // 1-indexed position of second last '1' up to previous j

    // Parity over prefix boundaries k=0..n
    long long cntPar1[2] = {0, 0};
    int firstPar1[2] = {-1, -1}, lastPar1[2] = {-1, -1};

    long long cntPar0[2] = {0, 0};
    int firstPar0[2] = {-1, -1}, lastPar0[2] = {-1, -1};

    // Initialize boundary k=0
    int par1 = 0; // #ones mod 2 up to k
    cntPar1[par1]++;
    firstPar1[par1] = 0;
    lastPar1[par1] = 0;
    int par0 = (0 & 1) ^ par1;
    cntPar0[par0]++;
    firstPar0[par0] = 0;
    lastPar0[par0] = 0;

    for (int j = 0; j < n; ++j) {
        const int b = s[j] & 1;
        const int j1 = j + 1;

        // 0100: 終端固定での加算（ここでは長さ>=2のみを数える）
        if (b == 1 && j >= 1) {
            if ((s[j - 1] & 1) == 0) {
                M0100 += j; // j1-1
                L0100 = max(L0100, j1);
            } else {
                // 直前も1なら、そのさらに前に1が必要
                M0100 += secondLastOneIdx;
                if (secondLastOneIdx > 0)
                    L0100 = max(L0100, j1);
            }
        }

        // 1101: 末尾 1 または（末尾 0 かつ前に 0）
        if (b == 1)
            M1101 += j1;
        else
            M1101 += lastZeroIdx;

        // pairs
        if (j >= 1) {
            int p = s[j - 1] & 1;
            if (!p && b)
                ++cnt01;
            if (p && !b)
                ++cnt10;
            if (p && b)
                ++cnt11;
        }
        // triples
        if (j >= 2) {
            int a = s[j - 2] & 1, c = s[j - 1] & 1;
            if (!a && !c && !b)
                ++cnt000;
            if (a && !c && b)
                ++cnt101;
            if (a && c && b)
                ++cnt111;
        }

        // runs
        if (b) {
            run1++;
            run0 = 0;
            sumAllOneSubs += run1;
            if (run1 > maxRun1)
                maxRun1 = run1;
        } else {
            run0++;
            run1 = 0;
            sumAllZeroSubs += run0;
        }

        // ones/zeros counts and positions
        if (b) {
            ++cnt1;
            sumPos1_1 += j1;
            if (first1 == -1)
                first1 = j;
            last1 = j;
        } else {
            ++cnt0;
        }

        // update parity at boundary k=j+1
        par1 ^= b;
        cntPar1[par1]++;
        if (firstPar1[par1] == -1)
            firstPar1[par1] = j1;
        lastPar1[par1] = j1;

        par0 = (j1 & 1) ^ par1;
        cntPar0[par0]++;
        if (firstPar0[par0] == -1)
            firstPar0[par0] = j1;
        lastPar0[par0] = j1;

        // lagging updates for 0100/1101
        if (b) {
            secondLastOneIdx = lastOneIdx;
            lastOneIdx = j1;
        } else {
            lastZeroIdx = j1;
        }
    }

    // -------- Backward pass (for 0010 / 1011) --------
    long long M0010 = 0, M1011 = 0; // M0010: ここでは長さ>=2のみ。後で +cnt1
    int minStart0010 = n;           // 最短開始 i（長さ>=2 を満たすもの）。L は
                                    // max(1(=単文字'1'があれば), n - i)
    int nextOne1 = n,
        nextOne2 = n; // nearest and 2nd-nearest '1' to the right of i
    int nextZero = n; // nearest '0' to the right of i

    for (int i = n - 1; i >= 0; --i) {
        const int b = (s[i] & 1);

        // 0010: 先頭1かつ（長さ>=2では：次が0 もしくは 次も1だがさらに右に1
        // がある）
        if (b == 1 && i + 1 < n) {
            if ((s[i + 1] & 1) == 0) {
                M0010 += (n - (i + 1));
                if (i < minStart0010)
                    minStart0010 = i;
            } else {
                if (nextOne2 < n) {
                    M0010 += (n - nextOne2);
                    if (i < minStart0010)
                        minStart0010 = i;
                }
            }
        }

        // 1011: 先頭 1 または（先頭 0 かつ以降に 0）
        if (b == 1) {
            M1011 += (n - i);
        } else {
            if (nextZero < n)
                M1011 += (n - nextZero);
        }

        // updates
        if (b == 1) {
            nextOne2 = nextOne1;
            nextOne1 = i;
        } else {
            nextZero = i;
        }
    }

    // -------- Derive L and M for each pattern --------

    // G1:
    long long M0000 = cnt1;
    int L0000 = (cnt1 > 0 ? 1 : -1);

    long long M0001 = sumAllOneSubs;
    int L0001 = (maxRun1 > 0 ? maxRun1 : -1);

    long long M0011 = cnt1 * (long long)(n + 1) - sumPos1_1;
    int L0011 = (cnt1 > 0 ? (n - first1) : -1);

    long long M0101 = sumPos1_1;
    int L0101 = (cnt1 > 0 ? (last1 + 1) : -1);

    long long M0111 = TOT - sumAllZeroSubs;
    int L0111 = (cnt1 > 0 ? n : -1);

    long long M1111 = TOT - cnt0;
    int L1111 = (n == 1 && (s[0] == '0')) ? -1 : n;

    // 0010: 単文字 '1' を追加で数える。L は単文字があれば少なくとも 1。
    M0010 += cnt1;
    int L0010 = (cnt1 > 0 ? 1 : -1);
    if (minStart0010 < n)
        L0010 = max(L0010, n - minStart0010);

    // 0100: 単文字 '1' を末尾として追加で数える。L も単文字で少なくとも 1。
    M0100 += cnt1;
    if (cnt1 > 0)
        L0100 = max(L0100, 1);

    // G2/G3: 1011/1101 の L は従来通り
    bool zeroAfterFirst = (n >= 2) ? (cnt0 - (s[0] == '0') >= 1) : false;
    int L1011 = ((n >= 1) && (s[0] == '1' || zeroAfterFirst))
                    ? n
                    : ((n >= 2) ? (n - 1) : -1);

    bool zeroBeforeLast = (n >= 2) ? (cnt0 - (s[n - 1] == '0') >= 1) : false;
    int L1101 = ((n >= 1) && (s[n - 1] == '1' || zeroBeforeLast))
                    ? n
                    : ((n >= 2) ? (n - 1) : -1);

    // G4: parity
    long long M0110 = cntPar1[0] * cntPar1[1];
    int L0110 = -1;
    if (firstPar1[0] != -1 && firstPar1[1] != -1) {
        if (lastPar1[0] != -1 && firstPar1[1] != -1)
            L0110 = max(L0110, lastPar1[0] - firstPar1[1]);
        if (lastPar1[1] != -1 && firstPar1[0] != -1)
            L0110 = max(L0110, lastPar1[1] - firstPar1[0]);
        if (L0110 <= 0) {
            if (M0110 == 0)
                L0110 = -1;
        }
    }

    long long M1001 = 0;
    for (int p = 0; p < 2; ++p) {
        if (cntPar0[p] >= 2)
            M1001 += (cntPar0[p] * (cntPar0[p] - 1)) / 2;
    }
    int L1001 = -1;
    for (int p = 0; p < 2; ++p) {
        if (cntPar0[p] >= 2) {
            L1001 = max(L1001, lastPar0[p] - firstPar0[p]);
        }
    }

    // G5: forbidden short patterns
    long long M1010 = TOT - cnt0 - cnt01 - cnt11;
    long long M1100 = TOT - cnt0 - cnt10 - cnt11;
    long long M1110 = TOT - cnt0 - cnt11 - cnt101;
    long long M1000 =
        TOT - cnt0 - cnt01 - cnt10 - cnt11 - cnt000 - cnt101 - cnt111;

    auto L_1010 = [&]() -> int {
        if (n >= 3)
            return n;
        if (n == 2)
            return (s != "01" && s != "11") ? 2 : 1;
        return (s[0] == '0' ? -1 : 1);
    };
    auto L_1100 = [&]() -> int {
        if (n >= 3)
            return n;
        if (n == 2)
            return (s != "10" && s != "11") ? 2 : 1;
        return (s[0] == '0' ? -1 : 1);
    };
    auto L_1110 = [&]() -> int {
        if (n >= 4)
            return n;
        if (n == 3)
            return (s != "101") ? 3 : 2;
        if (n == 2)
            return (s != "11") ? 2 : 1;
        return (s[0] == '0' ? -1 : 1);
    };
    auto L_1000 = [&]() -> int {
        if (n >= 4)
            return n;
        if (n == 3) {
            if (s == "000")
                return 2;
            if (s == "101")
                return 1;
            if (s == "111")
                return 1;
            return 3;
        }
        if (n == 2)
            return (s == "00") ? 2 : 1;
        return (s[0] == '0' ? -1 : 1);
    };

    int L1010 = L_1010();
    int L1100 = L_1100();
    int L1110 = L_1110();
    int L1000 = L_1000();

    // -------- Output in order 0000 .. 1111 --------
    cout << L0000 << ' ' << M0000 << '\n'; // 0000
    cout << L0001 << ' ' << M0001 << '\n'; // 0001
    cout << L0010 << ' ' << M0010 << '\n'; // 0010
    cout << L0011 << ' ' << M0011 << '\n'; // 0011
    cout << L0100 << ' ' << M0100 << '\n'; // 0100
    cout << L0101 << ' ' << M0101 << '\n'; // 0101
    cout << L0110 << ' ' << M0110 << '\n'; // 0110
    cout << L0111 << ' ' << M0111 << '\n'; // 0111
    cout << L1000 << ' ' << M1000 << '\n'; // 1000
    cout << L1001 << ' ' << M1001 << '\n'; // 1001
    cout << L1010 << ' ' << M1010 << '\n'; // 1010
    cout << L1011 << ' ' << M1011 << '\n'; // 1011
    cout << L1100 << ' ' << M1100 << '\n'; // 1100
    cout << L1101 << ' ' << M1101 << '\n'; // 1101
    cout << L1110 << ' ' << M1110 << '\n'; // 1110
    cout << L1111 << ' ' << M1111 << '\n'; // 1111

    return 0;
}
