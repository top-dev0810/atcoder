#include<bits/stdc++.h>

using namespace std;

using ll = long long;
using i32 = int;
using i64 = long long;
using i128 = __int128;

template<typename T,typename U>
ostream& operator<<(ostream& o,const tuple<T,U>& t){
	return o<<"("<<get<0>(t)<<","<<get<1>(t)<<")";
}

template<typename T>
ostream& operator<<(ostream& o,const vector<T>& vec){
	o<<"[";
	for(int i=0;i<vec.size();++i){
		o<<vec[i];
		if(i!=vec.size()-1)o<<",";
	}
	return o<<"]\n";
}

constexpr int M = 2e5+5, mod = 998244353;
constexpr double pi = acos(-1), eps = 1e-9;

void solve(){
	int n,m;
	cin>>n>>m;
	vector<string> a(n);
	for(auto& i:a)cin>>i;
	if(n<m){
		swap(n,m);
		vector<string> b(n);
		for(auto& i:a){
			for(int j=0;j<n;++j){
				b[j]+=i[j];
			}
		}
		a=move(b);
	}
	int s=1;
	for(int i=0;i<m;++i)s*=3;
	using ternary=vector<int>;
	auto nxt=[&](ternary& t){
		t.back()++;
		for(size_t i=t.size()-1;i;--i){
			t[i-1]+=t[i]/3;
			t[i]%=3;
		}
		bool flag=t.front()!=3;
		t.front()%=3;
		return flag;
	};
	auto state=[&](ternary& t){
		int s=0;
		for(auto i:t)s=s*3+i;
		return s;
	};
	auto to_ternary=[&](int s){
		ternary t(m);
		for(int i=m-1;~i;--i){
			t[i]=s%3;
			s/=3;
		}
		return t;
	};
	auto checkt1=[&](ternary& t){
		for(int i=1;i<m;++i){
			if(t[i]==t[i-1]){
				return false;
			}
		}
		return true;
	};
	auto checkt2=[&](ternary& t,int row,int col){
		for(int i=0;i<m;++i){
			if(a[row+(i<col)][i]=='?')continue;
			if(a[row+(i<col)][i]-'1'!=t[i])return false;
		}
		return true;
	};
	auto check1=[&](int s){
		int cur=-1;
		for(int i=0;i<m;++i){
			if(cur==s%3)return false;
			cur=s%3,s/=3;
		}
		return true;
	};
	auto check2=[&](int s,int row,int col){
		for(int i=m-1;~i;--i){
			int cur=s%3;
			s/=3;
			if(a[row+(i<col)][i]=='?')continue;
			if(a[row+(i<col)][i]-'1'!=cur)return false;
		}
		return true;
	};
	auto print=[&](vector<ll>& vec){
		for(int i=0;i<s;++i){
			auto t=to_ternary(i);
			if(!checkt1(t))continue;
			cout<<vec[i]<<" "<<t;
		}
	};
	vector<int> enums;
	vector<int> index(s,-1);
	int cnt=0;
	for(int i=0;i<s;++i){
		int cur=-1,t=i;
		int cnt0=0;
		for(int i=0;i<m;++i){
			if(cur==t%3)cnt0++;
			cur=t%3,t/=3;
		}
		if(cnt0<=1){
			enums.emplace_back(i);
			index[i]=cnt++;
		}
	}
	vector<ll> dp(cnt);
	for(int i=0;i<s;++i){
		if(!check1(i)||!check2(i,0,0))continue;
		dp[index[i]]=1;
	}
	for(int i=1;i<n;++i){
		int d=s;
		for(int j=0;j<m;++j){
			vector<ll> ndp(cnt);
			d/=3;
			if(j==0){
				for(auto t:enums){
					int u=index[t],v=t;
					if(!dp[u])continue;
					int cur=t/d;
					v-=cur*d;
					if(a[i][j]=='?'){
						for(auto k:{0,1,2}){
							if(k==cur)continue;
							(ndp[index[v+k*d]]+=dp[u])%=mod;
						}
					}
					else{
						v+=(a[i][j]-'1')*d;
						if(v==t)continue;
						(ndp[index[v]]+=dp[u])%=mod;
					}
				}
//				print(ndp);
			}
			else{
				for(auto t:enums){
					int u=index[t],v=t;
					if(!dp[u])continue;
					int x=t/d%3,y=t/d/3%3;
					v-=x*d;
					if(a[i][j]=='?'){
						for(auto k:{0,1,2}){
							if(k==x||k==y)continue;
							(ndp[index[v+k*d]]+=dp[u])%=mod;
						}
					}
					else{
						int z=(a[i][j]-'1');
						if(z==x||z==y)continue;
						(ndp[index[v+z*d]]+=dp[u])%=mod;
					}
				}
			}
			dp=move(ndp);
		}
	}
	ll ans=0;
	for(int i=0;i<s;++i){
		if(!check1(i))continue;
		(ans+=dp[index[i]])%=mod;
	}
	cout<<ans<<"\n";
	
	return;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	int t{1};
//	cin>>t;
	while(t--){
		solve();
	}
	
	return 0;
}
