// bitの大きい順に確定させていく
//連結かどうかを判定したいからufで十分、ただしbfsかdfsか何かで全探索が必要
#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for(long long i=0;i<n;i++)
using ll = long long;
using Graph = vector<vector<int>>;

struct UnionFind{
	vector<ll> par, rank, size, edge_count;
	// par[i] : iの親
	// rank[i] : iから一番下までの距離
	// size[i] : iを根とする集合の要素数
	// edge_count[i] : iを根とする集合の辺の数	
	UnionFind(ll N) : par(N), rank(N, 0), size(N, 1), edge_count(N, 0){ // 初期化 自分の親は自分自身とする
		for(int i = 0; i < N; i++)par[i] = i;
	}
	
	int root(ll x){ // xの根を返す
		if(par[x] == x)return x;
		return par[x] = root(par[x]); // 経路圧縮
	}
	
	void unite(ll x, ll y){ // xとyがそれぞれ含まれている二つの木の併合
		int rx = root(x); // それぞれの根を見つける
		int ry = root(y);
		if(rx == ry){// 根が同じ(元から同じ木に属している)ならそのまま
			edge_count[rx]++; // 辺の数を増やす
			return;
		}
		if(rank[rx] > rank[ry])swap(rx, ry); // 長い方を新たな根とする
		par[rx] = ry; // xの根の親をyの根に繋ぐ
		size[ry] += size[rx];
		edge_count[ry] += edge_count[rx] + 1;
		if(rank[rx] == rank[ry])rank[ry]++;
		return;
	}
	
	bool same(ll x, ll y){ // xとyが同じ木ならtrue,違うならfalseを返す
		return root(x) == root(y);
	}
	int get_edge_count(int x) { // xを含む木の辺の数を返す
    return edge_count[root(x)];
  }
  int get_size(int x) { // xを含む木の要素数を返す
    return size[root(x)];
  }
};
int main() {
  ll n, m;
  cin >> n >> m;
  vector<vector<pair<ll, ll>>> g(n);
  rep(i,m){
    ll a, b, c;
    cin >> a >> b >> c;
    a--;
    b--;
    g[a].emplace_back(b,c);
    g[b].emplace_back(a,c);
  }
  ll ans = 0;
  vector<bool> v(n,false);
  for(int i = 30; i >= 0; i--){
    ans = ans << 1;
    UnionFind uf(n);
    vector<bool> visited(n,false);
    queue<ll> que;
    que.push(0);
    visited[0] = true;
    while(!que.empty()){
      ll now = que.front();
      que.pop();
      for(auto [to, w] : g[now]){

        if(visited[to])continue;
        if(ll((w >> i)|ans) > ans || w >> i & 1)continue;
        uf.unite(now,to);
        que.push(to);
        visited[to] = true;
      }
    }

    if(!uf.same(0,n-1)){

      ans += 1;
    }
  }
  cout << ans;
	return 0;
}