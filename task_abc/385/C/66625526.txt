#include <bits/stdc++.h>
using namespace std;
template<class T> bool chmin(T& a, T b) { return a > b ? a = b, true : false; }
template<class T> bool chmax(T& a, T b) { return a < b ? a = b, true : false; }
template<typename T>
concept Iterable = requires(T t) { std::begin(t); std::end(t); };
template<typename T>
    requires Iterable<T> && (!is_same_v<T, string>)
ostream& operator<<(ostream& os, const T& container) { for (auto& element : container) os << element << ' '; return os; }
template<typename R>
    requires ranges::range<R> && (!is_same_v<decay_t<R>, string>) && (!is_same_v<decay_t<R>, const char*>)
ostream& operator<<(ostream& os, R&& range) { for (auto& element : range)os << element << ' '; return os; }
template<typename T>
    requires Iterable<T> && (!is_same_v<T, string>)
istream& operator>>(std::istream& is, T& container) { for (auto& e : container)is >> e; return is; }
using ll = long long;
using ull = unsigned long long;
using uint = unsigned int;
template<class T = ll> struct Edge {
    int to;
    T weight;
    bool operator==(Edge e) { return this->to == e.to and this->weight == e.weight; }
    bool operator<(Edge e) { return this->to == e.to ? this->weight < e.weight : this->to < e.to; }
};
#ifdef _DEBUG
#define SHOW(n) {const auto& _ret = n; cerr << #n << ": " << _ret << endl;}
#define MSG(x) cerr << x << endl;
#else
#define SHOW(n)
#define MSG(x)
#endif

//AtCoder Library 
#include <atcoder/all>
using namespace atcoder;
using mint = modint998244353;
//using mint = modint1000000007;
//using mint1 = dynamic_modint<0>;
//using mint = modint;
//mint::set_mod();
istream& operator>>(istream& is, mint& x) { ll r; is >> r; x = r; return is; }
ostream& operator<<(ostream& os, mint& x) { os << x.val(); return os; }

//boost
#include <boost/multiprecision/cpp_int.hpp>
using namespace boost::multiprecision;
using l3 = int128_t;


int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);

    int n;
    cin >> n;
    vector<int> h(n);
    cin >> h;

    int m = ranges::max(h);

    vector<vector<int>> idx(m + 1);

    for (int i = 0; i < n; ++i) {
        --h[i];
        idx[h[i]].push_back(i);
    }


    int res = 1;
    for (auto& v : idx) {
        if (v.size() == 0)continue;

        const int siz = v.size();
        vector<vector<int>> dp(siz + 1, vector<int>(n + 1, 1));

        for (int i = 1; i < siz; ++i) {
            for (int j = 0; j < i; ++j) {
                int d = v[i] - v[j];

                chmax(dp[i + 1][d], dp[j + 1][d] + 1);
            }
            chmax(res, ranges::max(dp[i + 1]));
        }
    }

    cout << res << endl;



    return 0;
}
