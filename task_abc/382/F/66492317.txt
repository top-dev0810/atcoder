#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;

struct Block{
    int r, c, l, id;
    bool operator< (const Block &W) const {
        if (r != W.r) return r > W.r;
        return c < W.c;
    }
} a[N];

int h, w, n;
int tr[N << 2], tag[N << 2];
int res[N];

void build(int u, int l, int r){
    if (l == r) {
        tr[u] = h;
        tag[u] = h;
        return ;
    }

    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    tag[u] = tr[u] = h;
}

void pushdown(int u, int l, int r){
    if (l != r){
        tag[u << 1] = min(tag[u], tag[u << 1]);
        tr[u << 1] = min(tag[u], tr[u << 1]);
        tag[u << 1 | 1] = min(tag[u], tag[u << 1 | 1]);
        tr[u << 1 | 1] = min(tag[u], tr[u << 1 | 1]);
    }
}

void update(int u, int l, int r, int L, int R, int x){
    if (L <= l && r <= R) {
        tag[u] = x;
        tr[u] = x;
        return ;
    }
    pushdown(u, l, r);
    int mid = l + r >> 1;
    if (L <= mid) update(u << 1, l, mid, L, R, x);
    if (R > mid) update(u << 1 | 1, mid + 1, r, L, R, x);
    tr[u] = min(tr[u << 1], tr[u << 1 | 1]);
}

int query(int u, int l, int r, int L, int R){
    if (L <= l && r <= R) return tr[u];
    pushdown(u, l, r);
    int mid = l + r >> 1, mn = 0x3f3f3f3f;
    if (L <= mid) mn = min(mn, query(u << 1, l, mid, L, R));
    if (R > mid) mn = min(mn, query(u << 1 | 1, mid + 1, r, L, R));
    return mn;
}

int main(){
    scanf("%d%d%d", &h, &w, &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d%d%d", &a[i].r, &a[i].c, &a[i].l), a[i].id = i;

    sort(a + 1, a + n + 1);

    build(1, 1, w);

    for (int i = 1; i <= n; i ++ ){
        res[a[i].id] = query(1, 1, w, a[i].c, a[i].c + a[i].l - 1);
        update(1, 1, w, a[i].c, a[i].c + a[i].l - 1, res[a[i].id] - 1);
    }

    for (int i = 1; i <= n; i ++ ) printf("%d ", res[i]);
	return 0;
}