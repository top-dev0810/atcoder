#include"bits/stdc++.h"
using namespace std;

#define int long long
#define V vector
#define pii pair<int,int>
#define msb(x) (63-__builtin_clzll(x))
#define popcount(x) (__builtin_popcountll(x))
#define rep(i,a,b) for(int i=(int)(a); i<(int)(b); i++)

#ifdef SEVEN
#else
#define cerr if(0) cout
#endif

// const Int MOD = 1e9+7;
int MOD;
int bpow(int a,int b){
	int ret = 1;
	for(;b; a=a*a%MOD,b/=2) if(b&1) ret = ret*a%MOD;
	return ret;
}
int inv(int a){return bpow(a,MOD-2);}

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

void solve(); int TC, ALLTC;
signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	srand(chrono::steady_clock::now().time_since_epoch().count());
	cout << fixed << setprecision(7);
	solve();
}

const int N = 33;
int n;
int C[N*N][N*N];
int f[N/2][N/2][N*N/2];
int dp[N/2][N/2][N/2][2][N*N/2];

void solve(){
	
	cin >> n >> MOD;

	rep(x,0,N*N) rep(y,0,x+1){
		if(y==0 || y==x) C[x][y] = 1;
		else (C[x][y] = C[x-1][y-1] + C[x-1][y])%=MOD;
	}
	for(int x=1; x<=n/2; x++)
	for(int y=1; y<=n/2; y++)
	for(int z=y; z<=x*y; z++){
		if(y==1){
			f[x][y][z] = C[x][z];
		}
		else{
			for(int k=1; k<z && k<=x; k++){
				(f[x][y][z] += 1LL *f[x][1][k] *f[x][y-1][z-k]%MOD )%=MOD;
			}
		}
	}
	for(int x=1; x<=n/2; x++)
	for(int y=1; y<=n/2; y++){
		for(int z=x*y + y*(y-1)/2; z>0; z--){
			for(int self=1; self<z; self++){				
				(f[x][y][z] += 1LL *f[x][y][z-self] *C[y*(y-1)/2][self]%MOD )%=MOD;
			}
		}
	}
	dp[0][1][1][0][0] = 1;
	for(int odd=0; odd<=n/2; odd++)
	for(int evn=1; evn<=n/2; evn++)
	for(int par=0; par<2; par++)
	for(int last=1; (par ? last<=odd : last<=evn); last++)
	for(int e=0; e<=odd*evn + odd*(odd-1)/2 + evn*(evn-1)/2; e++)
	if(dp[odd][evn][last][par][e] != 0){
		if(par == 0){
			for(int nxt=1; odd+nxt<=n/2; nxt++){
				for(int k=1; k<=last*nxt + nxt*(nxt-1)/2; k++){
					(dp[odd+nxt][evn][nxt][par^1][e+k] += 1LL *dp[odd][evn][last][par][e] *C[n-odd-evn][nxt]%MOD *f[last][nxt][k]%MOD )%=MOD;
				}
			}
		}
		else{
			for(int nxt=1; evn+nxt<=n/2; nxt++){
				for(int k=1; k<=last*nxt + nxt*(nxt-1)/2; k++){
					(dp[odd][evn+nxt][nxt][par^1][e+k] += 1LL *dp[odd][evn][last][par][e] *C[n-odd-evn][nxt]%MOD *f[last][nxt][k]%MOD )%=MOD;
				}
			}
		}
	}
	

	for(int e=n-1; e<=n*(n-1)/2; e++){
        int ans = 0;
        for(int last=1; last<=n/2; last++)
        for(int par=0; par<2; par++){
            (ans += dp[n/2][n/2][last][par][e] )%=MOD;
        }
        ans = (ans%MOD+MOD)%MOD;
        // Post-condition: Ensure result is within modulo bounds
        assert(0 <= ans && ans < MOD);
        cout << ans << " ";
    }
	cout << '\n';
	
}