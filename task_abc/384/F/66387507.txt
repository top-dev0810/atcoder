#include<bits/stdc++.h>
using i64 = long long;
const int N = 1e7;
const int M = 30;
i64 g[N + 1][2] , sum[N + 1] , cnt[N + 1] , tot = 0;
void append(i64 x){
    int p = 0;
    for(int i = 0; i < M; i++){
        sum[p] += x;
        cnt[p] += 1;
        int s = (x >> i & 1);
        if(g[p][s] == 0) g[p][s] = ++tot;
        p = g[p][s];
    }
    cnt[p] += 1;
    sum[p] += x;
    return ;
}
void erase(i64 x){
    int p = 0;
    for(int i = 0; i < M; i++){
        sum[p] -= x;
        cnt[p] -= 1;
        int s = (x >> i & 1);
        p = g[p][s];
    }
    cnt[p] -= 1;
    sum[p] -= x;
    return ;
}
i64 quiry(i64 x){
    i64 res = 0LL , now = 0LL , need = 1LL , tim = 0LL;
    bool ok = false;
    int p = 0;
    now = sum[p];
    tim = cnt[p];
    for(int i = 0; i < M; i++){
        int s = (x >> i & 1);
        if(s == 1){
            if(ok){
                if(g[p][1] != 0){
                    res += (sum[g[p][1]] + cnt[g[p][1]] * x) / need;
                    now -= sum[g[p][1]];
                    tim -= cnt[g[p][1]];
                }
                if(g[p][0] != 0){
                    p = g[p][0];
                }else{
                    break;
                }
            }else{
                if(g[p][0] != 0){
                    res += (sum[g[p][0]] + cnt[g[p][0]] * x) / need;
                    now -= sum[g[p][0]];
                    tim -= cnt[g[p][0]];
                }
                if(g[p][1] != 0){
                    p = g[p][1];
                }else{
                    break;
                }
                ok = true;
            }
        }else{
            if(ok){  
                if(g[p][0] != 0){
                    res += (sum[g[p][0]] + cnt[g[p][0]] * x) / need;
                    now -= sum[g[p][0]];
                    tim -= cnt[g[p][0]];
                }
                if(g[p][1] != 0){
                    p = g[p][1];
                }else{
                    break;
                }
              
            }else{
                if(g[p][1] != 0){
                    res += (sum[g[p][1]] + cnt[g[p][1]] * x) / need;
                    now -= sum[g[p][1]];
                    tim -= cnt[g[p][1]];
                }
                if(g[p][0] != 0){
                    p = g[p][0];
                }else{
                    break;
                }
            }
        }
        need = need << 1;
    }
    res += (now + tim * x) / need;
    return res;
}
int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(nullptr);

    int N;
    std::cin >> N;

    std::vector<int> A(N);
    for(int i = 0; i < N; i++){
        std::cin >> A[i];
    }

    i64 ans = 0LL;
    for(int i = 0; i < N; i++){
        append(A[i]);
    }

    for(int i = 0; i < N; i++){
        ans += quiry(A[i]);
        erase(A[i]);
    }

    std::cout << ans << '\n';
    return 0;
}