#include<bits/stdc++.h>
#define ll long long 
#define Poly vector<F>
using namespace std;
namespace IO{
    char buff[1<<21],*p1=buff,*p2=buff;
    char getch(){
        return p1==p2&&(p2=((p1=buff)+fread(buff,1,1<<21,stdin)),p1==p2)?EOF:*p1++;
    }
    template<typename T>
    void read(T &x){
        char ch=getch();int fl=1;x=0;
        while(ch>'9'||ch<'0'){if(ch=='-')fl=-1;ch=getch();}
        while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getch();}
        x*=fl;
    }
    template<typename T,typename ...Args>
    void read(T &x,Args& ...args){
        read(x);read(args...);
    }
    char obuf[1<<21],*p3=obuf;
    void putch(char ch){
        if(p3-obuf<(1<<21))*p3++=ch;
        else fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=ch;
    }
    void pc(const char *s){
    	while(*s)putch(*s),s++;
    }
    char ch[100];
    template<typename T>
    void write(T x){
        if(!x)return putch('0');
        if(x<0)putch('-'),x*=-1;
        int top=0;
        while(x)ch[++top]=x%10+48,x/=10;
        while(top)putch(ch[top]),top--;
    }
    template<typename T,typename ...Args>
    void write(T x,Args ...args){
        write(x),putch(' '),write(args...);
    }
    void flush(){fwrite(obuf,p3-obuf,1,stdout);}
}
using namespace IO;
const int N=45000,mod=998244353,g=3,ig=332748118,Inv_2=(mod+1)>>1,T=2*mod+2;
inline int Mod(int x){return x>=mod?x-mod:x;}
inline int poww(int x,int y){int sum=1;for(;y;y>>=1,x=1ll*x*x%mod)if(y&1)sum=1ll*sum*x%mod;return sum;}
struct F{
	int a,b;
	friend F operator +(const F A,const int B){return F{Mod(A.a+B),A.b};}
	friend F operator +(const int B,const F A){return F{Mod(A.a+B),A.b};}
	friend F operator -(const F A,const int B){return F{Mod(A.a+mod-B),A.b};}
	friend F operator -(const int B,const F A){return F{Mod(B+mod-A.a),Mod(mod-A.b)};}
	friend F operator *(const F A,const int B){return F{1ll*A.a*B%mod,1ll*A.b*B%mod};}
	friend F operator *(const int B,const F A){return F{1ll*A.a*B%mod,1ll*A.b*B%mod};}
	friend F operator +(const F A,const F B){return F{Mod(A.a+B.a),Mod(A.b+B.b)};}
	friend F operator -(const F A,const F B){return F{Mod(A.a+mod-B.a),Mod(A.b+mod-B.b)};}
	friend F operator *(const F A,const F B){return F{(1ll*A.a*B.a+5ll*A.b*B.b)%mod,(1ll*A.a*B.b+1ll*A.b*B.a)%mod};}
	friend F operator /(F A,F B){
		int x=(1ll*B.a*B.a-5ll*B.b*B.b)%mod;
		if(x<0)x+=mod;
		B.b=mod-B.b;A=A*B;
		return A*poww(x,mod-2);
	}
};
void Out_F(F a){cout<<'('<<a.a<<'+'<<a.b<<'Q'<<')';}
const F A={Inv_2,Inv_2},B={Inv_2,mod-Inv_2},D=A/B;
F PD[N<<1+5],PND[N<<1+5];
F calcD(int x){return PND[x/N]*PD[x%N];}
inline F poww(F x,ll y){F sum={1,0};for(;y;y>>=1,x=x*x)if(y&1)sum=sum*x;return sum;}
int rev[N<<3+5];
inline void Init(int len){for(int i=0;i<(1<<len);i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(len-1));}
inline void NTT(Poly &a,int len,int ops=1){
	for(int i=0;i<len;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int m=2;m<=len;m<<=1){
		int wn=poww(ops?g:ig,(mod-1)/m);
		for(int i=0;i<len;i+=m){
			int w=1;
			for(int j=0;j<m/2;j++){
				F u=a[i+j];
				F t=w*a[i+j+m/2];
				a[i+j]=u+t;
				a[i+j+m/2]=u-t;
				w=1ll*w*wn%mod;
			}
		}
	}
	if(!ops){
		int Inv=poww(len,mod-2);
		for(int i=0;i<len;i++)a[i]=a[i]*Inv;
	}
	return;
}
Poly operator *(Poly a,Poly b){
	int len=0,tmp=(int)a.size()+(int)b.size();
	while((1<<len)<tmp)len++;
	a.resize(1<<len),b.resize(1<<len);
	Init(len);
	NTT(a,1<<len,1),NTT(b,1<<len,1);
	for(int i=0;i<(1<<len);i++)a[i]=a[i]*b[i];
	NTT(a,1<<len,0);
	return a;
}
void Out_Poly(Poly a){
	for(int i=0;i<a.size();i++)cout<<'('<<a[i].a<<'+'<<a[i].b<<"i)x^"<<i<<'+';
	cout<<'\n';
}
Poly CZT(Poly a,int n,F c,int m){//多点求值 
	F ic=F{1,0}/c;
	for(int i=0;i<n;i++)
		a[i]=a[i]*poww(ic,1ll*i*(i-1)/2);
	reverse(a.begin(),a.end());
	Poly b;b.resize(n+m-1);
	for(int i=0;i<n+m-1;i++)
		b[i]=poww(c,1ll*i*(i-1)/2);
	a=a*b;
	Poly ans;
	for(int i=0;i<m;i++)ans.push_back(a[n+i-1]*poww(ic,1ll*i*(i-1)/2));
	return ans;
}
F c1,c2;
Poly sol(int len){
	Poly ans;
	if(len==1){
		ans.resize(2);
		ans[0]=c2;
		ans[1]=c1*D;
	}else if(len&1){
		Poly s;s.resize(2);
		s[0]=c2,s[1]=c1*calcD(len);
		ans=sol(len-1)*s;
	}else{
		int _len=len>>1;
		Poly s=sol(_len),t=s;
		F w=F{1,0},wn=calcD(_len);
		for(int i=0;i<t.size();i++){
			t[i]=t[i]*w;
			w=w*wn;
		}
		ans=s*t;
	}
	ans.resize(len+1);
	return ans;
}
Poly f,s;
int calc_ans(ll n){
	if(!n)return 1;
	if(n>T)return 1ll*poww(calc_ans(T),n/T)*calc_ans(n%T)%mod;
	F ans=(n>=N?s[n/N-1]:F{1,0});
	for(int i=(n/N)*N+1;i<=n;i++)ans=ans*(c1*poww(A,i)+c2*poww(B,i));
	return ans.a;
}
void sol(){
	ll n,x,y;
	read(n,x,y);
	c1=(Mod(y+mod-x)*B-x)/(B-A),c2=Mod(y+mod-x)-c1;
	f=sol(N);
	s=CZT(f,N+1,calcD(N),N);
	for(int i=0;i<s.size();i++)s[i]=s[i]*poww(B,1ll*N*(N+1+2ll*i*N)/2);
	for(int i=1;i<s.size();i++)s[i]=s[i-1]*s[i];
	write(calc_ans(n)),putch('\n');
}
signed main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	PD[0]=PND[0]=F{1,0};
	for(int i=1;i<=N;i++)PD[i]=D*PD[i-1];
	for(int i=1;i<=N;i++)PND[i]=PD[N]*PND[i-1];
	int T;read(T);
	while(T--)sol();
	return flush(),0;
}