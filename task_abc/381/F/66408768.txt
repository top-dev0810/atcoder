//#pragma GCC optimize(2)
#include<bits/stdc++.h>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int,int>PII;

#define rep(x, y, z) for(LL x = (y); x <= (z); ++x)
#define per(x, y, z) for(LL x = (y); x >= (z); --x)
#define fi first
#define se second
#define ls (u<<1)
#define rs (u<<1|1)
#define all(ss) ss.begin(),ss.end()
#define pb push_back
#define vi vector<int>
#define vii vector<vector<int>>
#define vl vector<LL>
#define vll vector<vector<LL>>
#define i128 __int128

int const mod=1e9+7;
int const B=507;
double const eps=1e-6;
//int const mod=998244353;
//const LL mod1=1e9+21,mod2=1e9+1e8+9;	//不大众的模数
//const LL base1=61,base2=31;	//不大众的底数
int const N=2e5+7,M=2e6+7;
int const INF=0x3f3f3f3f;
LL const INFF=0x3f3f3f3f3f3f3f3f;

int n,m,K;
int opt,x,y,z;
int a[N];
int ne[N][21];

/*
找到一个排列，使其在数组中出现2次
*/

void solve(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i]--;
	}
	
	//ne[i][j]:记录i为起点j值第一个出现的位置
	memset(ne,0x3f,sizeof ne);
	for(int i=n;i>=1;i--){
		for(int j=0;j<20;j++) ne[i][j]=ne[i+1][j];
		ne[i][a[i]]=i;
	}
	
	int tot=1<<20; 
	vector<int>f(tot+1,INF);
	f[0]=0;
	int ans=0;
	for(int s=0;s<tot;s++){
		int c=0;
		for(int i=0;i<20;i++){ //枚举下一个数填什么
			c+=s>>i&1;
			if(s>>i&1||f[s]+1>n) continue;
			int j=ne[f[s]+1][i];
			if(j+1>n) continue;
			j=ne[j+1][i];
			if(j<=n){
				f[s|(1<<i)]=min(f[s|(1<<i)],j); 
			}
		}
		if(f[s]<=n) ans=max(ans,c*2); //可以找到，记录1的数量
	}
	
	
	cout<<ans<<"\n";
}	


void init(){

}

int main()
{
// 	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
    //std::ios::sync_with_stdio(false);   cin.tie(0); cout.tie(0);
    //init();
    int T=1;
    //cin>>T;
    //scanf("%d",&T);

   	for(int i=1;i<=T;i++){
	   	solve();
	}

	return 0;
}