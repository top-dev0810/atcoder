#include <bits/stdc++.h>
using namespace std;

#define ALL(a) begin(a), end(a)
#define RALL(a) rbegin(a), rend(a)
using ll = int64_t;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
template<typename T> using Graph = vector<vector<T>>;
template<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;
constexpr int MOD = 998244353;
const int dx[4] = { 1, 0, -1, 0 };
const int dy[4] = { 0, 1, 0, -1 };
char interval[2] = {' ', '\n'};

template<typename T, typename... Args> auto make_vector(T x, int arg, Args... args) { if constexpr(sizeof...(args) == 0) return vector<T>(arg, x); else return vector(arg, make_vector<T>(x, args...)); }

template<typename T> struct is_plural : false_type{};
template<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};
template<typename T> struct is_plural<complex<T>> : true_type{};
template<typename T> struct is_plural<vector<T>> : true_type{};
template<> struct is_plural<string> : true_type{};

template<typename T1, typename T2> istream& operator>>(istream& is, pair<T1, T2>& p) { return is >> p.first >> p.second; }
template<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << p.first << ' ' << p.second; }
template<typename T> istream& operator>>(istream& is, complex<T>& x) { T a, b; is >> a >> b; x = complex<T>(a, b); return is; }
template<typename T> ostream& operator<<(ostream& os, const complex<T>& x) { return os << x.real() << ' ' << x.imag(); }
template<typename T> istream& operator>>(istream& is, vector<T>& vec) { for(auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }
template<typename T> ostream& operator<<(ostream& os, const vector<T>& vec) { if(vec.empty()) return os; os << vec.front(); for(auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[is_plural<T>()] << *itr; return os; }

inline bool CoutYN(bool a, string yes = "Yes", string no = "No") { cout << (a ? yes : no) << '\n'; return a; }

template<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { return a < b && (a = b, true); }
template<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { return a > b && (a = b, true); }

#ifdef _DEBUG
void dbg() { cerr << '\n'; }
template<typename T, typename... Args> void dbg(const T& x, const Args&... args) { cerr << '\n' << x; dbg(args...); }
template<typename... Args> inline void debugger(int line, const char* str, const Args&... args) { cerr << "\e[96m" << line << " [" << str << "]:\e[39m"; dbg(args...); };
#else
template<typename... Args> inline void debugger(int, const char*, const Args&...) {};
#endif
#define debug(...) debugger(__LINE__, #__VA_ARGS__, __VA_ARGS__)

#ifdef ENABLE_ARBITRARY_TEST
inline void prompt_bkgndclr(const char* cmd) { cout << cmd; }
#else
inline void prompt_bkgndclr(const char*) {}
#endif

#ifndef ENABLE_MIGHT_IO
inline bool might_set_range(int64_t low, int64_t high) { ignore = low, ignore = high; return false; }
inline void might_in() {}
template<typename T, typename... Args> inline void might_in(T& x, Args&... args) { cin >> x; might_in(args...); }
template<typename T, typename... Args> inline bool might_in_extra(T&, Args&...) { return false; }
template<typename T> inline bool might_in_extra_tree(vector<T>&, bool shuffle = true) { ignore = shuffle; return false; }
inline void might_out_impl() {}
template<typename T, typename... Args> inline void might_out_impl(const T& x, const Args&... args) { cout << x; might_out_impl(args...); }
template<typename... Args> inline void might_out(const Args&... args) { prompt_bkgndclr("\e[45m"); might_out_impl(args...); prompt_bkgndclr("\e[49m"); cout << '\n'; }
inline void might_finished() {}
#endif


/* -------- <insert libraries below> -------- */


/* -------- <templates end> -------- */


void solve() {
  int n, m; cin >> n >> m;
  vector<pii> uv(m); might_in(uv);

  if(n & 1) {
    CoutYN(m & 1, "Aoki", "Takahashi");
    return;
  }

  Graph<int> g(n);

  for(auto& [u, v] : uv) {
    --u, --v;
    g[u].emplace_back(v);
    g[v].emplace_back(u);
  }

  vector<bool> seen(n);
  vector<int> c(2);

  auto dfs = [&](auto dfs, int v, bool x) -> void {
    if(seen[v]) return;
    seen[v] = true, ++c[x];

    for(auto& nv : g[v]) {
      dfs(dfs, nv, x ^ true);
    }
  };

  vector<int> d(4);

  for(int i = 0; i < n; ++i) {
    if(seen[i]) continue;

    fill(ALL(c), 0);
    dfs(dfs, i, 0);

    if(c[0] + c[1] == 1) ++d[3];
    else ++d[(c[0] & 1) + (c[1] & 1)];
  }

  bool z = false;

  if(d[1] == 0) {
    z = ((d[2] + d[3] / 2) & 1) ^ (m & 1);
  } else if(d[1] <= 2) {
    z = true;
  } else {
    z = (m & 1);
  }

  CoutYN(z, "Aoki", "Takahashi");
}


/* -------- <programs end> -------- */


#ifndef GEOMETRY_HPP
namespace std { template<typename T> bool operator<(const complex<T>& l, const complex<T>& r) { return real(l) != real(r) ? real(l) < real(r) : imag(l) < imag(r); } }
#endif

signed main() {
  cin.tie(nullptr);
  ios::sync_with_stdio(false);
  cout << fixed << setprecision(12);
  solve();
  might_finished();
  return 0;
}
