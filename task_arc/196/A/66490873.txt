#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using P = pair<long long, long long>;
#define rep(i, a, b) for(long long i = (a); i < (b); ++i)
#define rrep(i, a, b) for(long long i = (a); i >= (b); --i)
constexpr long long inf = 4e18;
struct SetupIO {
    SetupIO() {
        ios::sync_with_stdio(0);
        cin.tie(0);
        cout << fixed << setprecision(30);
    }
} setup_io;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/tag_and_trait.hpp>
using namespace __gnu_pbds;
using SortedSet = tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update>;
using SortedMultiSet = tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update>;
int main(void) {
    ll n;
    cin >> n;
    vector<ll> a(n);
    rep(i, 0, n) {
        cin >> a[i];
    }
    if(n % 2 == 0) {
        ranges::sort(a);
        cout << accumulate(a.begin() + n / 2, a.end(), 0ll) - accumulate(a.begin(), a.begin() + n / 2, 0ll) << '\n';
    } else {
        vector<ll> l(n), r(n);
        {
            SortedMultiSet st;
            ll sum = 0, small = 0;
            for(ll i = 2; i < n; i += 2) {
                st.insert(a[i - 2]);
                st.insert(a[i - 1]);
                sum += a[i - 2] + a[i - 1];
                ll cnt = 0;
                if((ll)st.order_of_key(a[i - 2]) < i / 2) {
                    cnt++;
                    small += a[i - 2];
                }
                if((ll)st.order_of_key(a[i - 1]) < i / 2) {
                    cnt++;
                    small += a[i - 1];
                }
                if(cnt == 0) {
                    small += *st.find_by_order(i / 2 - 1);
                } else if(cnt == 2) {
                    small -= *st.find_by_order(i / 2);
                }
                l[i] = sum - 2 * small;
            }
        }
        {
            SortedMultiSet st;
            ll sum = 0, small = 0;
            for(ll i = n - 3; i >= 0; i -= 2) {
                st.insert(a[i + 2]);
                st.insert(a[i + 1]);
                sum += a[i + 2] + a[i + 1];
                ll cnt = 0;
                if((ll)st.order_of_key(a[i + 2]) < (n - 1 - i) / 2) {
                    cnt++;
                    small += a[i + 2];
                }
                if((ll)st.order_of_key(a[i + 1]) < (n - 1 - i) / 2) {
                    cnt++;
                    small += a[i + 1];
                }
                if(cnt == 0) {
                    small += *st.find_by_order((n - 1 - i) / 2 - 1);
                } else if(cnt == 2) {
                    small -= *st.find_by_order((n - 1 - i) / 2);
                }
                r[i] = sum - 2 * small;
            }
        }
        ll ans = 0;
        for(ll i = 0; i < n; i += 2) {
            ans = max(ans, l[i] + r[i]);
        }
        cout << ans << '\n';
    }
}
