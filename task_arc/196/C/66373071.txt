#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read() {
    ll x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
const int N = 4e5 + 10, mod = 998244353;
//分治fft??????? 换一些状态？？？
ll jc[N], jcn[N]; int n; char a[N];
ll qpow(ll x, ll y) {
	ll ans = 1;
	while (y) {
		if (y & 1) ans = (ans * x) % mod;
		x = (x * x) % mod; y >>= 1;
	} return ans;
}
ll f[N]; int s[N];
typedef vector<ll> vl;
int len;
void brs(vl &a) {
	for (int i = 0, j = 0; i < len; i++) {
		if (i < j) swap(a[i], a[j]);
		for (int l = len >> 1; (j ^= l) < l; l >>= 1);	
	}
}
void ntt(vl &a, int d) {
	brs(a);
	for (int i = 1; i < len; i <<= 1) {
		ll w = qpow(3, (mod - 1) / i / 2);
		if (d == -1) w = qpow(w, mod - 2);
		for (int j = 0; j < len; j += (i << 1)) {
			ll wn = 1;
			for (int k = 0; k < i; k++) {
				ll x = a[j+k], y = wn * a[j+k+i] % mod;
				a[j+k] = (x + y) % mod;
				a[j+k+i] = (x - y) % mod;
				wn = (wn * w) % mod;
			}
		}
	}	
	if (d == -1) {
		ll inv = qpow(len, mod - 2);
		for (int i = 0; i < len; i++) a[i] = (a[i] * inv) % mod;
	}
}	
vl mul(vl a, vl b) {
	int tot = a.size() + b.size() - 1;
	len = 1;
	while (len <= tot) len <<= 1;	
	a.resize(len, 0); b.resize(len, 0);
	ntt(a, 1); ntt(b, 1);
	for (int i = 0; i < len; i++) a[i] = (a[i] * b[i]) % mod;
	ntt(a, -1);
	a.resize(tot, 0);
	return a;
}
void solve(int l, int r) {
	if (l == r) {
		if (!l) return;
		if (l - 2 * s[l] >= 0) f[l] *= jcn[l-2*s[l]];
		else f[l] = 0;
		f[l] = -f[l]; 
		f[l] %= mod;
		return;
	} int mid = (l + r) >> 1;
	solve(l, mid);
	vl a, b; 
	int l1 = s[l], r1 = s[mid];
	int l3 = mid+1-s[mid+1], r3 = r-s[r]; 
	int l2 = l3 - r1, r2 = r3 - l1;
	l2 = max(l2, 0); r2 = max(r2, 0);
	a.resize(r1-l1+1, 0); b.resize(r2-l2+1, 0);
	for (int i = l; i <= mid; i++) (a[s[i]-l1] += f[i]) %= mod;
	//s[l]~s[mid]   ->  ln~rn
	for (int i = l2; i <= r2; i++) b[i-l2] = jc[i];
	//ln-s[mid] ~ rn-s[l]
	vl c = mul(a, b);
	for (int i = mid + 1; i <= r; i++) {
		int nw = i - s[i] - l2 - l1;
		assert(nw < int(c.size()));
//		if (nw >= int(c.size())) {
////			cerr << nw << ' ' << c.size() << '\n';
//		}
		if (nw >= 0) (f[i] += c[nw]) %= mod;
	}
	solve(mid + 1, r);
}
int main(){
	n = read();
	scanf("%s", a + 1);
	jc[0] = jcn[0] = 1;
	for (int i = 1; i < N; i++) jc[i] = (jc[i-1] * i) % mod;
	jcn[N-1] = qpow(jc[N-1], mod - 2);
	for (int i = N - 2; i >= 1; i--) jcn[i] = (jcn[i+1] * (i + 1)) % mod;
	reverse(a + 1, a + 2 * n + 1);
	for (int i = 1; i <= 2 * n; i++) {
		s[i] = s[i-1] + (a[i] == 'W');
	}
	f[0] = 1;
	solve(0, 2 * n);
//	for (int i = 1; i <= 2 * n; i++) {
//		if (i - 2 * s[i] < 0) {
//			f[i] = 0; continue;
//		}
//		for (int j = 0; j < i; j++) {
//			int nw = i - s[i] - s[j]; 
//			if (nw < 0) break;
////			if (nw >= 0) 
//			(f[i] += jc[nw] * f[j]) %= mod; //!!!!!构造nw + j 等于定值。 发现j-s[j]不是定值
//			//但是可以把j贡献到s[j]上，这样卷积就是定值了 
//		}
//		if (i - 2 * s[i] >= 0) f[i] *= jcn[i-2*s[i]];
//		else f[i] = 0;
//		f[i] = -f[i]; 
//		f[i] %= mod;
////		cerr << f[i] << ' ';
//	}
	ll sum = -f[2*n]; sum = (sum % mod + mod) % mod;
	cout << sum;
	return 0;
}


