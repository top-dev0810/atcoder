#include<bits/stdc++.h>
using namespace std;

// #define endl '\n'
#define rep(i, a, b) for(int i = (a); i <= (b); i++)
#define per(i, a, b) for(int i = (a); i >= (b); i--)
#define rept(i, a, ne) for(int i = (a); ~i ; i=ne[i])
#define debug(x) cout<<#x<<": "<<x<<endl
#define fi first
#define sec second
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
typedef long long LL;
typedef long double  LD;
typedef unsigned long long ULL;
typedef vector<int> VI;
typedef pair<LL,LL>PII;
const int N=1e3+10;;

int primes[N], cnt;     // primes[]存储所有素数1-cnt
int st[N];         // st[x]存储x是否被筛掉
int a[N][N];
int bo[N];
int dp[N][10*N][2];
LL c[N*10];
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[++cnt  ] = i;
        for (int j = 1; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = primes[j];
            if (i % primes[j] == 0) break;
        }
    }
}
LL mod=998244353;
LL qmi(LL a,LL b)
{
    LL sum=1;
    while (b)
    {
        if(b&1)
        sum=sum*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return sum;
}
void slove()
{
    get_primes(1e3);
    int n;
    cin>>n;
    rep(i,1,n-1)
    {
        int x;
        cin>>x;
        while(st[x])
        {
            a[st[x]][i]++;  
            bo[st[x]]=1;
            x/=st[x];

        }
        if(x>1)
        {
           a[x][i]++;
            bo[x]=1; 
        }
    }
    LL ans=1;
    rep(i,2,1e3)
    if(bo[i])
    {
        int m=0;
        rep(j,1,n)
        {
            m+=a[i][j];
        }
        rep(j,0,n)
        rep(k,0,m)
        dp[j][k][1]=dp[j][k][0]=0;
        c[0]=1;
        rep(j,1,m)
        c[j]=c[j-1]*i%mod;
        rep(j,0,n-1)
        {
            rep(k,0,m)
            {
                if(j==0)
                {
                    dp[j][0][1]=1;
                    if(k)
                    dp[j][k][0]=c[k];
                    continue;
                } 
                int w=a[i][j];
                if(k==0)
                {
                    dp[j][0][1]=dp[j-1][w][1];
                    if(w)
                    dp[j][0][1]+=dp[j-1][w][0];
                    dp[j][0][1]%=mod;
                    dp[j][0][0]=0;
                }
                else
                {
                    rep(o,0,1)
                    {
                        dp[j][k][o]=0;
                        if(k+w<=m)
                        dp[j][k][o]+=dp[j-1][k+w][o]*c[k]%mod;
                        dp[j][k][o]%=mod;    

                        if(w&&(k-w>=0))
                        dp[j][k][o]+=dp[j-1][k-w][o]*c[k]%mod;
                        dp[j][k][o]%=mod;
                    }
                }
            }
        }
        // rep(j,0,n-1)
        // rep(k,0,m)
        // {
        //     debug(j);
        //     debug(k);
        //     debug(dp[j][k][1]);
        //     debug(dp[j][k][0]);
        // }
        LL su=0;
        rep(k,0,m)
        su=(su+dp[n-1][k][1])%mod;
        ans*=su;
        ans%=mod;
    }
    cout<<ans<<endl;
}

int main()
{
    // freopen("test.in","r",stdin);
    // freopen("test.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
//	cout << fixed << setprecision(9);
    int t=1;
	// cin>>t;
    while(t--)
    {
        slove();
    }


    return 0;
}
//#pragma GCC optimize(2)