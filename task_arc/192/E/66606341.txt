#include <bits/stdc++.h>
using namespace std;
const long long MOD = 998244353LL;

// -------- 組合せ前計算 --------
struct Comb {
    vector<long long> fact, invfact;
    Comb(int n = 0) { init(n); }
    long long modpow(long long a,long long e=MOD-2)const{
        long long r=1;
        while(e){ if(e&1) r=r*a%MOD; a=a*a%MOD; e>>=1; }
        return r;
    }
    void init(int n){
        fact.resize(n+1); invfact.resize(n+1);
        fact[0]=1;
        for(int i=1;i<=n;++i) fact[i]=fact[i-1]*i%MOD;
        invfact[n]=modpow(fact[n]);
        for(int i=n;i>=1;--i) invfact[i-1]=invfact[i]*i%MOD;
    }
    long long C(long long n,long long k)const{
        if(k<0||k>n) return 0;
        return fact[n]*invfact[k]%MOD*invfact[n-k]%MOD;
    }
};

// F(a,b)=C(a+b+2,a+1)-1
inline long long F(int a,int b,const Comb& C){
    return (C.C(a+b+2,a+1)+MOD-1)%MOD;
}

// G(A,B)=Σ_{i=0..A}Σ_{j=0..B}C(i+j+2,i+1) = C(A+B+4,A+2)-(A+2)-(B+2)
inline long long G(int A,int B,const Comb& C){
    long long val = C.C(A+B+4, A+2);
    val = (val - (A+2) - (B+2))%MOD;
    if(val<0) val+=MOD;
    return val;
}

// 二次元区間和  G(A1,B1)-G(A0-1,B1)-G(A1,B0-1)+G(A0-1,B0-1)
long long rangeG(int A0,int A1,int B0,int B1,const Comb& C){
    long long res = G(A1,B1,C);
    if(A0>0) res = (res - G(A0-1,B1,C) + MOD)%MOD;
    if(B0>0) res = (res - G(A1,B0-1,C) + MOD)%MOD;
    if(A0>0 && B0>0) res = (res + G(A0-1,B0-1,C))%MOD;
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    long long W,H,L,R,D,U;
    if(!(cin>>W>>H>>L>>R>>D>>U)) return 0;

    Comb C(W+H+4);                 // 階乗前計算

    /* --- 1. 全経路数 --- */
    long long T_full = C.C(W+H+4, W+2);
    T_full = (T_full - (W+2) - (H+2) - (W+1)*(H+1))%MOD;
    if(T_full<0) T_full += MOD;

    /* --- 2. 種類 A（内側始点） --- */
    int A0 = W - R,  A1 = W - L;
    int B0 = H - U,  B1 = H - D;
    long long sumC = rangeG(A0, A1, B0, B1, C);
    long long rect = ( (R-L+1LL)*(U-D+1LL) ) % MOD;
    long long A = (sumC - rect + MOD) % MOD;

    /* --- 3. 種類 B（西側から侵入） --- */
    long long Bsum = 0;
    if(L>0){
        for(long long y=D; y<=U; ++y){
            long long pre = (C.C(L+y+1, L) - 1 + MOD)%MOD;
            long long suf = F(W - L, H - y, C);
            Bsum = (Bsum + pre*suf)%MOD;
        }
    }

    /* --- 4. 種類 C（南側から侵入） --- */
    long long Csum = 0;
    if(D>0){
        for(long long x=L; x<=R; ++x){
            long long pre = (C.C(x+D+1, x+1) - 1 + MOD)%MOD;
            long long suf = F(W - x, H - D, C);
            Csum = (Csum + pre*suf)%MOD;
        }
    }

    /* --- 5. 答え --- */
    long long ans = (T_full - A - Bsum - Csum) % MOD;
    if(ans<0) ans += MOD;
    cout << ans << '\n';
    return 0;
}
