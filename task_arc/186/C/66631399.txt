///////////////////////////////////////////////////////////////////////
////////// SCROLL ALL THE WAY DOWN FOR PROBLEM SPECIFIC CODE //////////
///////////////////////////////////////////////////////////////////////

#include <bits/stdc++.h>
using namespace std;

////////////// DEBUG UTILS /////////////////
#ifndef ONLINE_JUDGE
  #include "../../../../lib/debug/debug.h"
  #define debug(...) \
  if(DEBUG_CASENUM < 0 || DEBUG_CASENUM == CASENUM) { \
    dbg(__VA_ARGS__); \
  }
#else
  #define debug(...) {}
  #define dbg(...) {}
  #define expect(cond,...) {assert(cond);}
  #define ARRAY_BOUNDS_CHECK_SKIP
  #define STACK_TRACE_SKIP
  #define STD_FORMAT_SKIP
#endif

//////////// LIBRARY CODE IF ANY ///////////
#line 17 "array.h"

// An Array wraps a vector

struct Permutation {
  int n;
  std::vector<int> v;

  Permutation(int _n):n(_n),v(_n) {
    for(int i=0;i<n;i++) v[i] = i;
  }

  Permutation(const Permutation& that) {
    __copyFrom(that);
  }

  Permutation& operator=(const Permutation& that) {
    if(&that == this) {
      return *this;
    }
    __copyFrom(that);
    return *this;
  }

  Permutation(Permutation&& that) {
    __moveFrom(std::move(that));
  }

  Permutation& operator=(Permutation&& that) {
    if(&that == this) {
      return *this;
    }
    __moveFrom(std::move(that));
    return *this;
  }

  ~Permutation() {
  }

  inline int& operator()(int idx) {
    return v[idx];
  }

  inline const int& operator()(int idx) const {
    return v[idx];
  }

  inline int size() const {
    return n;
  }

  /// Input = [3,1,0,2], Output = [2, 1, 3, 0]
  void inverse() {
    std::vector<int> temp(n);
    for(int i=0;i<n;i++) temp[v[i]] = i;
    for(int i=0;i<n;i++) v[i] = temp[i];
  }

  void reverse() {
    std::reverse(v.begin(), v.end());
  }

  long long int inversionCount() const {
    if(n == 0) return 0;

    std::vector<int> W = v;
    std::vector<int> temp(n);
    return invCount(temp, W, 0, n-1);
  }

  private:

  void __copyFrom(Permutation const& that) {
    n = that.n;
    v = that.v;
  }

  void __moveFrom(Permutation&& that) {
    std::swap(n, that.n);
    std::swap(v, that.v);
  }

  long long int invCount(std::vector<int>& temp, std::vector<int>& W, int lo, int hi) const {
    assert(hi >= lo);
    if(lo == hi) {
      return 0;
    }

    int mid = (lo+hi)/2;
    long long int a = invCount(temp, W, lo, mid);
    long long int b = invCount(temp, W, mid+1, hi);
    long long int c = sortAndGetInvCount(temp, W, lo, mid, hi);
    return a + b + c;
  }

  // Merge Sort elements of W in range [lo, hi] assuming [lo, mid] and [mid+1, hi] are sorted
  long long int sortAndGetInvCount(std::vector<int>& temp, std::vector<int>& W, int lo, int mid, int hi) const {
    int l = lo;
    int r = mid+1;
    int cnt = lo;
    long long int ret = 0;

    while(l <= mid && r <= hi) {
      if(W[l] < W[r]) {
        temp[cnt++] = W[l++];
      } else {
        assert(W[l] > W[r]); // no dups
        temp[cnt++] = W[r++];
        ret += (mid+1 - l);
      }
    }

    while(r <= hi) temp[cnt++] = W[r++];
    while(l <= mid) temp[cnt++] = W[l++];
    for(int i=lo;i<=hi;i++) W[i] = temp[i];
    return ret;
  }
};

std::ostream& operator<<(std::ostream& os, Permutation const& v) {
  os<<v.size()<<" vals. [ ";
  for(int i=0;i<v.size();i++) {
    if(i)os<<", ";
    os<<v(i);
  }
  os<<" ]";
  return os;
}

template<typename T>
class Array1 {

  template<typename> struct is_array1 : std::false_type {};
  template<typename> struct is_array2 : std::false_type {};

  template<typename W> struct is_array1<Array1<W>> : std::true_type {
    typedef W type;
  };

  template<typename W> struct is_array2<Array1<Array1<W>>> : std::true_type {
    typedef W type;
  };

  template<typename W> struct not_array1 : std::true_type {
    typedef W type;
  };

  template<typename W> struct not_array1<Array1<W>> : std::false_type {};

  typedef typename std::vector<T>::iterator iterator;
  typedef typename std::vector<T>::const_iterator const_iterator;

  private:  
  int loIdx;
  std::vector<T> data;
  bool throwOnOob;
  T specialVal;

  public:
  //////////////////// Constructors /////////////////
  Array1() {
    init(0, -1);
  }

  Array1(std::initializer_list<T> values) {
    init(0, -1 + (int)values.size());
    data.assign(values.begin(), values.end());
  }

  Array1(const std::vector<T>& values) {
    init(0, -1 + (int)values.size());
    data.assign(values.begin(), values.end());
  }

  Array1(int size) {
    init(0, size-1);
  }

  Array1(int size, const T& value) {
    init(0, size-1);
    std::fill(data.begin(), data.end(), value);
  }

  Array1(int size, std::function<T()> reader) {
    init(0, size-1);
    for(int i=0;i<size;i++)
      data[i] = reader();
  }

  ///////////////// Settings ////////////////
  Array1& oobSpecialVal() {
    // Consider propagating in n-d array case for n>1.
   throwOnOob = false;
   return *this;
  }

  ///////////////// Accessors ////////////////
  inline T& operator()(int idx) {
    if(isOOB(idx)) {
      return specialVal;
    }
    return data[idx-loIdx];
  }

  inline T& operator()(long long int idx) {
    if(isOOB(idx)) {
      return specialVal;
    }
    return data[idx-loIdx];
  }

  inline T& operator()(auto idx) {
    if(isOOB(idx.mask - loIdx)) {
      return specialVal;
    }
    // idx is of type BitMask
    return data[idx.mask-loIdx];
  }

  inline const T& operator()(int idx) const {
    if(isOOB(idx)) {
      return specialVal;
    }
    return data[idx-loIdx];
  }

  inline const T& operator()(long long int idx) const {
    if(isOOB(idx)) {
      return specialVal;
    }
    return data[idx-loIdx];
  }

  inline const T& operator()(auto idx) const {
    if(isOOB(idx.mask - loIdx)) {
      return specialVal;
    }
    // idx is of type BitMask
    return data[idx.mask-loIdx];
  }
  
  // returns W& if T = Array1<W>
  inline typename is_array1<T>::type& operator()(int row, int col) {
    if(isOOB(row)) {
      return specialVal.operator()(col);
    }
    return data[row-loIdx].operator()(col);
  }
  
  inline const typename is_array1<T>::type& operator()(int row, int col) const {
    if(isOOB(row)) {
      return specialVal.operator()(col);
    }
    return data[row-loIdx].operator()(col);
  }

  // returns W& if T = Array1<Array1<W>>
  inline typename is_array2<T>::type& operator()(int row, int col, int z) {
    if(isOOB(row)) {
      return specialVal.operator()(col, z);
    }
    return data[row-loIdx].operator()(col, z);
  }

  // returns W& if T = Array1<Array1<W>>
  inline typename is_array2<T>::type& operator()(int row, int col, int z) const {
    if(isOOB(row)) {
      return specialVal.operator()(col, z);
    }
    return data[row-loIdx].operator()(col, z);
  }

  inline bool isOOB(int idx) const {
#ifndef ARRAY_BOUNDS_CHECK_SKIP
    if(idx < loIdx || idx >= loIdx + size()) {
      if(throwOnOob) {
        std::ostringstream oss;
        oss<< "Out of bounds error" << std::endl;
        oss<< "idx = " << idx << std::endl;
        oss<< "Range = [" << loIdx << " to " << loIdx + size() << ")" << std::endl;
        oss<< "\nStacktrace\n";
        oss<< "----------\n";
        oss<<std::stacktrace::current()<<std::endl;
        throw std::runtime_error(oss.str());
      } else {
        return true;
      }
    }
#endif        
    return false;
  }

  ///////////////// State //////////////
  
  inline int size() const {
    return data.size();
  }

  inline Array1::const_iterator begin() const {
    return data.begin();
  }

  inline Array1::iterator begin() {
    return data.begin();
  }

  inline Array1::const_iterator end() const {
    return data.end();
  }

  inline Array1::iterator end() {
    return data.end();
  }

  bool operator==(const Array1<T>& that) const {
    return loIdx == that.loIdx && data == that.data;
  }

  inline T& first() {
    return data[0];
  }

  inline const T& back() const {
    return data.back();
  }

  inline T& back() {
    return data.back();
  }

  inline bool empty() {
    return size() == 0;
  }

  void printLine(std::ostream& os) const {
    for(auto x : *this) {
      os<<x<<" ";
    }
    os<<std::endl;
  }

  /////////////// Readonly Algorithms /////////////////

  // TODO: Make this (start, step, filter) and call the method `stepUntil()`. Introduce `doUntil()`
  // Returns smallest x>=0 such that func(*this(start+x)) is true
  // If no such x exists, returns [loIdx + size()].
  int firstAscending(int start, std::function<bool(const T&, int idx)> func) const {
    assert(start >= loIdx);
    int n = size();
    for(int i=start-loIdx;i<n; i++)
      if(func(data[i], i+loIdx))
        return i + loIdx;
    return n + loIdx;
  }

  // Returns smallest x>=0 such that func(*this(start-x)) is true
  // If no such x exists, returns [loIdx - 1].
  int firstDescending(int start, std::function<bool(const T&, int idx)> func) const {
    int n = size();
    assert(start < loIdx+n);
    for(int i=start-loIdx;i>=0; i--)
      if(func(data[i], i+loIdx))
        return i + loIdx;
    return -1 + loIdx;
  }

  T max() const {
    return *max_element(begin(), end());
  }

  T min() const {
    return *min_element(begin(), end());
  }

  int lower_bound_idx(T needle) const {
   return loIdx + (std::lower_bound(data.begin(), data.end(), needle) - data.begin());
  }

  T lower_bound(T needle, T notFound) const {
   int x = std::lower_bound(data.begin(), data.end(), needle) - data.begin();
    if(x == size())
      return notFound;
    return data[x];
  }

  long long xorSum() const {
    long long ret = 0;
    int sz = size();
    for(int i=0;i<sz;i++)
      ret ^= data[i];
    return ret;
  }

  long long sum() const {
    long long ret = 0;
    int sz = size();
    for(int i=0;i<sz;i++)
      ret += data[i];
    return ret;
  }

  // Returns  an array of accumulated sum, starting with a value of 0.
  // ret(loIdx) = 0, ret(loIdx+1) = this(loIdx), ret(loIdx+2) = this(loIdx) + this(loIdx+1) ...
  Array1<T> cumsum() const {
    Array1<T> ret = Array1<T>(1,0).withLoIndex(loIdx);
    int sz = size();
    for(int i=0;i<sz;i++)
      ret.push_back(ret.back() + data[i]);
    return ret;
  }

  template<typename X>
  X reduce(X identity, std::function<X(X, const T&)> accumulator) {
    X ret = identity;
    for(const auto& t : data) {
      ret = accumulator(ret, t);
    }
    return ret;
  }

  Array1<T> subArray(int lo, int hiExclusive) {
    assert(lo >= loIdx && hiExclusive >= lo && hiExclusive <= lo + size());
    Array1<T> out(hiExclusive-lo);
    for(int i=lo;i<hiExclusive;i++)
      out(i-lo) = data[loIdx + i];
    return out;
  }

  //////////////// Manipulations ///////////////////

  Array1<T>& concat(Array1<T> const& that) {
    for(T const& elem : that) {
      push_back(elem);
    }
    return *this;
  }

  void resize(int x) {
    data.resize(x);
  }

  // Allow indexing to start from 'lo'
  Array1<T>& withLoIndex(int lo) {
    loIdx = lo;
    return *this;
  }

  Array1<T>& fill(T value) {
    std::fill(data.begin(), data.end(), value);
    return *this;
  }

  Array1<T>& reverse() {
    std::reverse(begin(), end());
    return *this;
  }

  Array1<T>& reverse(Permutation& p) {
    std::reverse(begin(), end());
    p.reverse();
    return *this;
  }

  Array1<T>& rotateLeft(int n) {
    n %= size();
    if(n<0) n+=size();
    if(n>0) rotate(data.begin(), data.begin() + n, data.end());
    return *this;
  }

  Array1<T>& next_permutation() {
    std::next_permutation(data.begin(), data.end());
    return *this;
  }

  Array1<T>& uniq() {
    data.erase(unique(data.begin(), data.end()), data.end());
    return *this;
  }

  Array1<int> compressCoordinates() {
    std::map<T, int> index;
    for(T& val : *this) index[val]=0;
    int count = 0;
    for(auto& [_,v] : index) v = count++;

    for(int i=0;i<size();i++)
      data[i] = index[data[i]];
    return *this;
  }

  Array1<T>& sort(Permutation& p, std::function<bool(T,T)> cmp) {
    std::vector<std::pair<T, int>> v(size());
    for(int i=0;i<size();i++)
      v[i] = std::make_pair(std::move(data[i]), p(i)); 

    auto cmp1 = [=](std::pair<T,int> a, std::pair<T,int> b) {
      bool leftLt = cmp(a.first, b.first);
      if(leftLt) return true;
      bool rightLt = cmp(b.first, a.first);
      if(rightLt) return false;
      return a.second < b.second;
    };
    std::sort(v.begin(), v.end(), cmp1);

    for(int i=0;i<size();i++)
      data[i] = std::move(v[i].first);
    for(int i=0;i<size();i++)
      p(i) = v[i].second;

    return *this;
  }

  Array1<T>& sort(Permutation& p) {
    std::vector<std::pair<T, int>> v(size());
    for(int i=0;i<size();i++)
      v[i] = std::make_pair(std::move(data[i]), p(i)); 

    std::sort(v.begin(), v.end());

    for(int i=0;i<size();i++)
      data[i] = std::move(v[i].first);
    for(int i=0;i<size();i++)
      p(i) = v[i].second;

    return *this;
  }

  Array1<T>& sort() {
    std::sort(begin(), end());
    return *this;
  }

  Array1<T>& sort(std::function<bool(T,T)> cmp) {
    std::sort(begin(), end(), cmp);
    return *this;
  }

  Array1<T>& push_back(const T& value) {
    data.push_back(value);
    return *this;
  }

  Array1<T>& push_back(T&& value) {
    data.push_back(std::move(value));
    return *this;
  }

  Array1<T>& pop_back() {
    data.pop_back();
    return *this;
  }

  Array1<T>& insert(int pos, const T& value) {
    data.insert(data.begin() + (pos-loIdx), value);
    return *this;
  }

  /////////////// COPY and MOVE constructors //////////////
  Array1& operator=(std::initializer_list<T> values) {
    init(0, -1 + (int)values.size());
    data.assign(values.begin(), values.end());
    return *this;
  }

  Array1(const Array1& that) {
    __copyFrom(that);
  }

  Array1& operator=(const Array1& that) {
    if(&that == this) {
      return *this;
    }
    __copyFrom(that);
    return *this;
  }

  Array1(Array1&& that) {
    __moveFrom(std::move(that));
  }

  Array1& operator=(Array1&& that) {
    if(&that == this) {
      return *this;
    }
    __moveFrom(std::move(that));
    return *this;
  }

  ~Array1() {
  }

  /////////////// COPY and MOVE constructors //////////////

  private:
  void init(int lo, int hi) {
    if(lo > hi+1) {

        std::ostringstream oss;
        oss<< "Expected hi >= lo - 1. hi="<<hi<<" lo="<<lo <<std::endl;
#ifndef ONLINE_JUDGE        
        oss<< "\nStacktrace\n";
        oss<< "----------\n";
        oss<<std::stacktrace::current()<<std::endl;
#endif        
        throw std::runtime_error(oss.str());
    }
    loIdx = lo;
    data = std::vector<T>(hi-lo+1);
    throwOnOob = true;
  }

  void __copyFrom(const Array1<T>& that) {
    loIdx = that.loIdx;
    data = that.data;
  }

  void __moveFrom(Array1<T>&& that) {
    std::swap(loIdx, that.loIdx);
    std::swap(data, that.data);
  }

  friend bool operator<(const Array1<T>& left, const Array1<T>& right) {
    if(left.loIdx == right.loIdx) {
      return left.data < right.data;
    }
    return left.loIdx < right.loIdx;
  }
};

template<class T> std::ostream& operator <<(std::ostream& os, const Array1<T>& v) {
  os<<v.size()<<" vals. [ ";
  for(int i=0;i<v.size();i++) {
    if(i)os<<", ";
    os<<v(i);
  }
  os<<" ]";
  return os;
}
  
#define AW Array1<W>
#define AAW Array1<AW>
#define AAAW Array1<AAW>
#define AAAAW Array1<AAAW>
#define AAAAAW Array1<AAAAW>

template<typename W>
static AW arrayfill(const W& val, int a) {
  return AW(a,val);
}

template<typename W>
static AAW arrayfill(const W& val, int a, int b) {
  return AAW(a,AW(b,val));
}

template<typename W>
static AAAW arrayfill(const W& val, int a, int b, int c) {
  return AAAW(a,AAW(b,AW(c,val)));
}

template<typename W>
static AAAAW arrayfill(const W& val, int a, int b, int c, int d) {
  return AAAAW(a,AAAW(b,AAW(c,AW(d,val))));
}

template<typename W>
static AAAAW arrayfill(const W& val, int a, int b, int c, int d,int e) {
  return AAAAAW(a,AAAAW(b,AAAW(c,AAW(d,AW(e,val)))));
}

#undef AAAAAW
#undef AAAAW
#undef AAAW
#undef AAW
#undef AW


////////////// TYPEDEFS ///////////////////
typedef long long int lint;
typedef long long int pint; // used for pii type
typedef pair<pint, pint> pii;
typedef Array1<int> VI;
typedef Array1<lint> VL;
typedef Array1<pii> VP;
typedef Array1<string> VS;
typedef Array1<VI> VVI;
typedef Array1<VL> VVL;
typedef Array1<VS> VVS;
typedef __int128 kint;
template <typename T> using VV = Array1<T>;
template <typename T> using VV2 = VV<VV<T>>;
template <typename T> using VV3 = VV<VV<T>>;
template <typename T> using VV4 = VV<VV<T>>;

////////////// UPDATES ///////////////////
template<class T> inline bool maxi(T& cur, const T& cand) {if(cand > cur) {cur = cand; return true;} return false;}
template<class T> inline bool mini(T& cur, const T& cand) {if(cand < cur) {cur = cand; return true;} return false;}
 
////////////// IO ////////////////////////
int ri() {int x;if(scanf(" %d",&x) == EOF) return -1;return x;}
lint rl() {lint x;if(scanf(" %lld",&x) == EOF) return -1; return x;}
string rs(int n) {char buf[n+2]; scanf(" %s ", buf); return string(buf);}
pii rp() {pint x=rl(); pint y=rl(); return {x, y};}
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
 
////////// CONVENIENCE #DEFINES //////////
#define fo(a,b) for(int a=0;a<b;++a)
#define foi(x,a,b) for(int x=a;x<=b;++x)
#define ALL(v) v.begin(),v.end()
#define pb push_back
#define todo expect(0==1,0);

#define AA2(type, name, n1, n2) static type _a_##name[n1][n2];\
  static Arr2<type,n1,n2> name = {_a_##name};
#define AA22(type, name, n1, n2, val) static type _a_##name[n1][n2];\
  static Arr2<type,n1,n2> name = {_a_##name, val, n1, n2};
#define AA3(type, name, n1, n2, n3) static type _a_##name[n1][n2][n3];\
  static Arr3<type,n1,n2,n3> name = {_a_##name};
#define AA33(type, name, n1, n2, n3, val) static type _a_##name[n1][n2][n3];\
  static Arr3<type,n1,n2,n3> name = {_a_##name, val, n1, n2, n3};
#define AA4(type, name, n1, n2, n3, n4) static type _a_##name[n1][n2][n3][n4];\
  static Arr4<type,n1,n2,n3,n4> name = {_a_##name};
#define AA44(type, name, n1, n2, n3, n4, val) static type _a_##name[n1][n2][n3][n4];\
  static Arr4<type,n1,n2,n3,n4> name = {_a_##name, val, n1, n2, n3, n4};

// From https://trap.jp/post/1224/
#define overload6(a, b, c, d, e, f, g, ...) g
#define AA(...) overload6(__VA_ARGS__,AA4,AA3,AA2)(__VA_ARGS__)

////////// CONSTANTS //////////
const lint inf = (1LL<<61);

///////////////////////////////////////////////////////////////////////
///////////////////////// PROBLEM SPECIFIC CODE ///////////////////////
/////////////////////// ONLY READ FROM HERE BELOW. ////////////////////
//////////// ABOVE IS LIBRARY CODE WITH A READABLE API ////////////////
///////////////////////////////////////////////////////////////////////

#line 101 "MAIN.cc"

//////////////////// INIT. One time computations ///////////////

int CASENUM = -1;
int DEBUG_CASENUM = 1;

void init() {}

struct Box {
  lint price;
  lint capacity;
};

ostream& operator<<(ostream& os, Box const& box) {
  char buf[50];
  sprintf(buf, "Box(p %lld, c %lld)", box.price, box.capacity);
  os<<string(buf);
  return os;
}

struct SingleCase {

  void solveCase() {
    int n = ri();
    int m = ri();
    VV<Box> boxes;
    fo(i,n) {
      lint c = rl();
      lint p = rl();
      boxes.pb({p,c});
    }
    if(m > n) {
      printf("0\n");
      return;
    }

    expect(m <= n, m, n);
    auto cmp = [](Box const& lt, Box const& rt) {
      return lt.capacity > rt.capacity;
    };
    boxes.sort(cmp);
    debug(boxes);

    VL cumgain(n,0);
    for(int i=n-1;i>=0;i--) {
      lint curgain = max(0LL, boxes(i).capacity - boxes(i).price);
      cumgain(i) = (i+1 < n ? cumgain(i+1) : 0) + curgain;
    }
    debug(cumgain);

    lint leastPriceSum = 0;
    multiset<lint> leastP;
    leastP.insert(-inf);
    for(int i=0;i+1<m;i++) {
      leastPriceSum += boxes(i).price - 1;
      leastP.insert(boxes(i).price-1);
    }
    debug(leastP, leastPriceSum);

    lint ret = 0;
    for(int i=m-1;i<n;i++) {
      lint curbest = cumgain(i) - leastPriceSum;
      maxi(ret, curbest);

      auto it = leastP.end(); --it;
      lint curp = boxes(i).price - 1;
      if(curp < *it) {
        leastPriceSum = leastPriceSum - *it + curp;
        leastP.erase(it);
        leastP.insert(curp);
      }
    }

    cout<<ret<<endl;
  }
};

////////// MAIN LOOP. Support both: specify case count upfront or until EOF //////////

const bool COUNTED_CASES=true;

void doMain(bool countedCases) {
  CASENUM=0;
  int cases = countedCases ? ri() : (1<<30);
  while(cases-- > 0) {
    CASENUM++;
#ifndef ONLINE_JUDGE
    fprintf(stderr,"%s Case %d debug %s\n",string(40, '-').c_str(), CASENUM, string(40,'-').c_str());
#endif
    SingleCase().solveCase();
    if(!countedCases) {
      scanf(" ");
      if(cin.peek() == EOF) break;
    }
  }
}

int main() {  
  init();
  doMain(COUNTED_CASES);
}

