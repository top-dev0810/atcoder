#include <bits/stdc++.h>
#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)
#define all(x) (x).begin(), (x).end()
#define sz(x) int(x.size())
using namespace std;
using ll = long long;
constexpr int INF = 1e9;
constexpr ll LINF = 1e18;
string YesNo(bool cond) {
    return cond ? "Yes" : "No";
}
string YESNO(bool cond) {
    return cond ? "YES" : "NO";
}
template <class T>
bool chmax(T& a, const T& b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}
template <class T>
bool chmin(T& a, const T& b) {
    if (b < a) {
        a = b;
        return true;
    }
    return false;
}
template <typename T, class F>
T bisect(T ok, T ng, const F& f) {
    while (abs(ok - ng) > 1) {
        T mid = min(ok, ng) + (abs(ok - ng) >> 1);
        (f(mid) ? ok : ng) = mid;
    }
    return ok;
}
template <typename T>
T floor_div(const T a, const T b) {
    assert(b != 0);
    return a / b - static_cast<T>((a ^ b) < 0 && a % b != 0);
}
template <typename T>
T ceil_div(const T a, const T b) {
    assert(b != 0);
    return a / b + static_cast<T>((a ^ b) >= 0 && a % b != 0);
}
template <typename T>
bool a_mul_b_eq_c(const T a, const T b, const T c) {
    return c % a == 0 && b == c / a;
}
template <typename T>
bool a_mul_b_le_c(const T a, const T b, const T c) {
    return b <= floor_div(c, a);
}
template <typename T>
bool a_mul_b_lt_c(const T a, const T b, const T c) {
    return a_mul_b_le_c(a, b, c) && !a_mul_b_eq_c(a, b, c);
}
template <typename T>
bool a_mul_b_ge_c(const T a, const T b, const T c) {
    return !a_mul_b_lt_c(a, b, c);
}
template <typename T>
bool a_mul_b_gt_c(const T a, const T b, const T c) {
    return !a_mul_b_le_c(a, b, c);
}
template <class T>
vector<T> make_vec(size_t a) {
    return vector<T>(a);
}
template <class T, class... Ts>
auto make_vec(size_t a, Ts... ts) {
    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));
}
template <typename T>
istream& operator>>(istream& is, vector<T>& v) {
    for (int i = 0; i < int(v.size()); i++) {
        is >> v[i];
    }
    return is;
}
template <typename T>
ostream& operator<<(ostream& os, const vector<T>& v) {
    for (int i = 0; i < int(v.size()); i++) {
        os << v[i];
        if (i < sz(v) - 1) os << ' ';
    }
    return os;
}
int naive() {
    ll n, k;
    cin >> n >> k;
    vector<ll> xs;
    for (ll x = 0; x < 2 * n; x++) {
        // if ((x ^ n) == x - n) xs.push_back(x);
        if ((x | n) == x) xs.push_back(x);
    }
    if (sz(xs) < k) {
        cout << -1 << '\n';
    } else {
        cout << xs[--k] << '\n';
    }
    return 0;
}
int solve() {
    int n, k;
    cin >> n >> k;
    k--;
    int msb = 0;
    rep(i, 31) if (n >> i & 1) {
        chmax(msb, i);
    }
    int d = 0;
    rep(i, msb) if (~n >> i & 1) {
        d++;
    }
    if (k >= (1 << d)) {
        cout << -1 << '\n';
        return 0;
    }
    int j = 0;
    rep(i, msb) if (~n >> i & 1) {
        if (k >> j & 1) {
            n |= 1 << i;
        }
        j++;
    }
    cout << n << '\n';
    return 0;
}
int main() {
    int tt;
    cin >> tt;
    while (tt--) solve();
}