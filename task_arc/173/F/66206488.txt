#include<bits/stdc++.h>
using namespace std;

#define int ll
typedef long long ll;
typedef unsigned long long ull;

#define mk make_pair
#define fi first
#define se second
typedef pair<int,int> pii;
typedef pair<double,double> pdd;

#define ReadIn(s) freopen(s,"r",stdin)
#define OutPut(s) freopen(s,"w",stdout)

#define btpcll(x) __builtin_popcountll(x)
#define btpc(x) __builtin_popcount(x)

#define eb emplace_back
#define sz(x) (int)(x.size())

template<typename T>
void read(T &x){
	x=0;char c=getchar();T neg=0;
	while(!isdigit(c)) neg|=!(c^'-'),c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	if(neg) x=(~x)+1;
}
template<typename T,typename ...Args>
void read(T &x,Args &...args) {
	read(x);read(args...);
}

const int M=6e5+10;
const int inf=0x3f3f3f3f3f3f3f3f;
const double eps=1e-10;
const int p=998244353;

inline int comp (double x,double y) {
	if(x-y>eps) return 1;
	if(y-x>eps) return -1;
	return 0;
}

bool Mst;
//in this

int n;
int A,B;

int fr[M];
int ifr[M];
int inv[M];

int expow(int x,int y) {
	
	if(y<0) return 0;
	
	int res=1;
	for(;y;y>>=1,x=x*x%p) if(y&1) res=res*x%p;
	return res;
}
inline int INV(int x) {
	return expow(x,p-2);
}

void Init(int M=M-1) {
	fr[0]=ifr[0]=1;inv[1]=1;
	for(int i=1;i<=M;i++) fr[i]=fr[i-1]*i%p;
	ifr[M]=INV(fr[M]);
	for(int i=M-1;i;i--) ifr[i]=ifr[i+1]*(i+1)%p,inv[i+1]=fr[i]*ifr[i+1]%p;
}
inline int C(int n,int m) {
	if(n<m||n<0||m<0) return 0;
	return fr[n]*ifr[m]%p*ifr[n-m]%p;
}

inline int _fr(int x) {
	return x<0?0:fr[x];
}
inline int _ifr(int x) {
	return x<0?0:ifr[x];
}

void solve() {
	read(n,A,B);
	
	int w1=0,w2=0,w3=0,w4=0;
	
	for(int i=0;i<=n-1;i++) {
		(w1+=C(n-1,i)*expow(A,n-1-i)%p*expow(B,i)%p*_ifr(A-i)%p*_ifr(B-(n-1-i))%p*expow(n,A-i+B-(n-1-i)))%=p;
	}
	
	for(int i=0;i<=n-2;i++) {
		(w2+=C(n-2,i)*expow(A,n-2-i)%p*expow(B,i)%p*_ifr(A-1-i)%p*_ifr(B-1-(n-2-i))%p*expow(n,A-1-i+B-1-(n-2-i)))%=p;
	}w2=2*(p-1)*(n-1)%p*w2%p;
	
	for(int i=0;i<=n-3;i++) {
		(w3+=C(n-3,i)*expow(A,n-3-i)%p*expow(B,i)%p*_ifr(A-2-i)%p*_ifr(B-2-(n-3-i))%p*expow(n,A-2-i+B-2-(n-3-i)))%=p;
	}w3=(n-2)*(n-1)%p*w3%p;
	
	for(int i=0;i<=n-3;i++) {
		(w4+=C(n-3,i)*expow(A,n-3-i)%p*expow(B,i)%p*_ifr(A-1-i)%p*_ifr(B-1-(n-3-i))%p*expow(n,A-1-i+B-1-(n-3-i)))%=p;
		(w4+=C(n-3,i)*expow(A,n-3-i)%p*expow(B,i)%p*_ifr(A-1-i)%p*_ifr(B-2-(n-3-i))%p*expow(n,A-1-i+B-2-(n-3-i)))%=p;
		(w4+=C(n-3,i)*expow(A,n-3-i)%p*expow(B,i)%p*_ifr(A-2-i)%p*_ifr(B-1-(n-3-i))%p*expow(n,A-2-i+B-1-(n-3-i)))%=p;
		(w4+=C(n-3,i)*expow(A,n-3-i)%p*expow(B,i)%p*_ifr(A-2-i)%p*_ifr(B-2-(n-3-i))%p*expow(n,A-2-i+B-2-(n-3-i)))%=p;
	}w4=(p-1)*(n-2)%p*(n-1)%p*w4%p;
	
//	cout<<w1<<" "<<w2<<" "<<w3<<" "<<w4<<"\n";
//	cout<<(w1+w2+w3+w4)%p<<"\n";
	
	cout<<inv[n]*fr[A]%p*fr[B]%p*(w1+w2+w3+w4)%p; 
	
}

//
bool Med;

signed main() {
	Init();
	
	solve();
	
	cerr<<"\n";
	cerr<<"Memory:"<<(&Mst-&Med)/1024.0/1024<<" MB\n";
	cerr<<"Time:"<<clock()/1.0/CLOCKS_PER_SEC*1000.0<<" ms\n";

	return 0;
}
