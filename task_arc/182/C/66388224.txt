#include <bits/stdc++.h>
using namespace std;
using ll=long long;
using ull=unsigned long long;
using P=pair<ll,ll>;
template<typename T>using minque=priority_queue<T,vector<T>,greater<T>>;
template<typename T>bool chmax(T &a,const T &b){return (a<b?(a=b,true):false);}
template<typename T>bool chmin(T &a,const T &b){return (a>b?(a=b,true):false);}
template<typename T1,typename T2>istream &operator>>(istream &is,pair<T1,T2>&p){is>>p.first>>p.second;return is;}
template<typename T1,typename T2,typename T3>istream &operator>>(istream &is,tuple<T1,T2,T3>&a){is>>std::get<0>(a)>>std::get<1>(a)>>std::get<2>(a);return is;}
template<typename T,size_t n>istream &operator>>(istream &is,array<T,n>&a){for(auto&i:a)is>>i;return is;}
template<typename T>istream &operator>>(istream &is,vector<T> &a){for(auto &i:a)is>>i;return is;}
template<typename T1,typename T2>void operator++(pair<T1,T2>&a,int n){a.first++,a.second++;}
template<typename T1,typename T2>void operator--(pair<T1,T2>&a,int n){a.first--,a.second--;}
template<typename T>void operator++(vector<T>&a,int n){for(auto &i:a)i++;}
template<typename T>void operator--(vector<T>&a,int n){for(auto &i:a)i--;}
#define overload3(_1,_2,_3,name,...) name
#define rep1(i,n) for(int i=0;i<(int)(n);i++)
#define rep2(i,l,r) for(int i=(int)(l);i<(int)(r);i++)
#define rep(...) overload3(__VA_ARGS__,rep2,rep1)(__VA_ARGS__)
#define reps(i,l,r) rep2(i,l,r)
#define all(x) x.begin(),x.end()
#define pcnt(x) __builtin_popcountll(x)
#define fin(x) return cout<<(x)<<'\n',static_cast<void>(0)
#define yn(x) cout<<((x)?"Yes\n":"No\n")
#define uniq(x) sort(all(x)),x.erase(unique(all(x)),x.end())
template<typename T>
inline int fkey(vector<T>&z,T key){return lower_bound(z.begin(),z.end(),key)-z.begin();}
ll myceil(ll a,ll b){return (a+b-1)/b;}
template<typename T,size_t n,size_t id=0>
auto vec(const int (&d)[n],const T &init=T()){
  if constexpr (id<n)return vector(d[id],vec<T,n,id+1>(d,init));
  else return init;
}
#ifdef LOCAL
#include<debug.h>
#define SWITCH(a,b) (a)
#else
#define debug(...) static_cast<void>(0)
#define debugg(...) static_cast<void>(0)
#define SWITCH(a,b) (b)
template<typename T1,typename T2>ostream &operator<<(ostream &os,const pair<T1,T2>&p){os<<p.first<<' '<<p.second;return os;}
#endif
struct Timer{
  clock_t start;
  Timer(){
    start=clock();
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout<<fixed<<setprecision(16);
  }
  inline double now(){return (double)(clock()-start)/1000;}
  #ifdef LOCAL
  ~Timer(){
    cerr<<"time:";
    cerr<<now();
    cerr<<"ms\n";
  }
  #endif
}timer;
void SOLVE();
int main(){
  int testcase=1;
  //cin>>testcase;
  for(int i=0;i<testcase;i++){
    SOLVE();
  }
}
#include<type_traits>
#include<optional>
constexpr int carmichael_constexpr(int n){
  if(n==998244353)return 998244352;
  if(n==1000000007)return 1000000006;
  if(n<=1)return n;
  int res=1;
  int t=0;
  while(n%2==0){
    n/=2;
    t++;
  }
  if(t==2)res=2;
  else if(t>=3)res=1<<(t-2);
  for(int i=3;i*i<=n;i++)if(n%i==0){
    int c=0;
    while(n%i==0){
      n/=i;
      c++;
    }
    int prod=i-1;
    for(int j=0;j<c-1;j++)prod*=i;
    res=std::lcm(res,prod);
  }
  if(n!=1)res=std::lcm(res,n-1);
  return res;
}
template<int m>
struct mod_int{
private:
  static constexpr unsigned int umod=static_cast<unsigned int>(m);
  static constexpr unsigned int car=carmichael_constexpr(m);
  using uint=unsigned int;
  using mint=mod_int;
  uint v;
  static_assert(m<uint(1)<<31);
  mint sqrt_impl()const{
    if(this->val()<=1)return *this;
    if constexpr(m%8==1){
      mint b=2;
      while(b.pow((m-1)/2).val()==1)b++;
      int m2=m-1,e=0;
      while(m2%2==0)m2>>=1,e++;
      mint x=this->pow((m2-1)/2);
      mint y=(*this)*x*x;
      x*=*this;
      mint z=b.pow(m2);
      while(y.val()!=1){
        int j=0;
        mint t=y;
        while(t.val()!=1)t*=t,j++;
        z=z.pow(1<<(e-j-1));
        x*=z;
        z*=z;
        y*=z;e=j;
      }
      return x;
    }
    else if constexpr(m%8==5){
      mint ret=this->pow((m+3)/8);
      if((ret*ret).val()==this->val())return ret;
      else return ret*mint::raw(2).pow((m-1)/4);
    }
    else{
      return this->pow((m+1)/4);
    }
  }
public:
  using value_type=uint;
  mod_int():v(0){}
  template<typename T,std::enable_if_t<std::is_signed_v<T>,std::nullptr_t> =nullptr>
  mod_int(T a){
    a%=m;
    if(a<0)v=a+umod;
    else v=a;
  }
  template<typename T,std::enable_if_t<std::is_unsigned_v<T>,std::nullptr_t> =nullptr>
  mod_int(T a):v(a%umod){}
  static constexpr mint raw(int a){
    mint ret;
    ret.v=a;
    return ret;
  }
  inline uint val()const{return this->v;}
  static constexpr int mod(){return m;}
  inline mint &operator+=(const mint &b){
    this->v+=b.v;
    if(this->v>=umod)this->v-=umod;
    return *this;
  }
  inline mint &operator-=(const mint &b){
    this->v-=b.v;
    if(this->v>=umod)this->v+=umod;
    return *this;
  }
  inline mint &operator*=(const mint &b){
    this->v=((unsigned long long)this->v*b.v)%umod;
    return *this;
  }
  inline mint &operator/=(const mint &b){
    *this*=b.inv();
    return *this;
  }
  inline mint operator+()const{return *this;}
  inline mint operator-()const{return mint()-*this;}
  friend inline mint operator+(const mint &a,const mint &b){return mint(a)+=b;}
  friend inline mint operator-(const mint &a,const mint &b){return mint(a)-=b;}
  friend inline mint operator*(const mint &a,const mint &b){return mint(a)*=b;}
  friend inline mint operator/(const mint &a,const mint &b){return mint(a)/=b;}
  friend inline bool operator==(const mint &a,const mint &b){return a.val()==b.val();}
  friend inline bool operator!=(const mint &a,const mint &b){return !(a==b);}
  inline mint operator++(int){
    mint ret=*this;
    *this+=mint::raw(1);
    return ret;
  }
  inline mint operator--(int){
    mint ret=*this;
    *this-=mint::raw(1);
    return ret;
  }
  mint pow(long long n)const{
    mint ret=mint::raw(1),a(*this);
    while(n){
      if(n&1)ret*=a;
      a*=a;
      n>>=1;
    }
    return ret;
  }
  inline mint inv()const{
    assert(this->v!=0);
    return pow(car-1);
  }
  std::optional<mint>sqrt()const{
    if(this->val()<=1||this->pow((m-1)/2)==1)return std::make_optional(this->sqrt_impl());
    else return std::nullopt;
  }
  static constexpr unsigned int order(){return car;}
  friend std::istream &operator>>(std::istream &is,mint &b){
    long long a;
    is>>a;
    b=mint(a);
    return is;
  }
  friend std::ostream &operator<<(std::ostream &os,const mint &b){
    os<<b.val();
    return os;
  }
};
template<int m>
struct std::hash<mod_int<m>>{
  std::size_t operator()(mod_int<m>x)const{
    return std::hash<unsigned int>()(x.val());
  }
};
using mint998=mod_int<998244353>;
using mint107=mod_int<1000000007>;
template<typename T>
constexpr std::enable_if_t<(std::numeric_limits<T>::digits<=32),T>pow_mod(T a,T n,T mod){
  using u64=unsigned long long;
  u64 res=1;
  while(n>0){
    if(n&1)res=((u64)res*a)%mod;
    a=((u64)a*a)%mod;
    n>>=1;
  }
  return T(res);
}
template<typename T>
constexpr std::enable_if_t<(std::numeric_limits<T>::digits>32),T>pow_mod(T a,T n,T mod){
  using u128=__uint128_t;
  u128 res=1;
  while(n>0){
    if(n&1)res=((u128)res*a)%mod;
    a=((u128)a*a)%mod;
    n>>=1;
  }
  return T(res);
}
constexpr int primitive_root_constexpr(int x){
  if(x==167772161)return 3;
  if(x==469762049)return 3;
  if(x==754974721)return 11;
  if(x==880803841)return 26;
  if(x==998244353)return 3;
  if(x==2)return 1;
  int x2=x;
  int p[20]={};
  int c=0;
  x--;
  for(int i=2;i*i<=x;i++){
    if(x%i==0){
      p[c++]=i;
      while(x%i==0)x/=i;
    }
  }
  if(x!=1)p[c++]=x;
  x=x2;
  for(int g=2;;g++){
    bool ok=true;
    for(int i=0;i<c;i++)if(pow_mod(g,(x-1)/p[i],x)==1){
      ok=false;
      break;
    }
    if(ok)return g;
  }
}
#include<concepts>
template<typename T>
constexpr std::enable_if_t<std::numeric_limits<T>::digits<=32,int>msb(T n){return n==0?-1:31-__builtin_clz(n);}
template<typename T>
constexpr std::enable_if_t<(std::numeric_limits<T>::digits>32),int>msb(T n){return n==0?-1:63-__builtin_clzll(n);}

template<typename T>
constexpr std::enable_if_t<std::numeric_limits<T>::digits<=32,int>lsb(T n){return n==0?-1:__builtin_ctz(n);}
template<typename T>
constexpr std::enable_if_t<(std::numeric_limits<T>::digits>32),int>lsb(T n){return n==0?-1:__builtin_ctzll(n);}

template<typename T>
constexpr std::enable_if_t<std::is_integral_v<T>,T>floor_pow2(T n){return n==0?0:T(1)<<msb(n);}

template<typename T>
constexpr std::enable_if_t<std::is_integral_v<T>,T>ceil_pow2(T n){return n<=1?1:T(1)<<(msb(n-1)+1);}

template<std::integral T>
constexpr T safe_div(T a,T b){return a/b-(a%b&&(a^b)<0);}
template<std::integral T>
constexpr T safe_ceil(T a,T b){return a/b+(a%b&&(a^b)>0);}
template<int m>
struct ntt_root{
  static constexpr int rank2=lsb(m-1);
  static constexpr int g=primitive_root_constexpr(m);
  std::array<int,rank2+1>root,invroot;
  std::array<int,std::max(0,rank2-1)>rate2,invrate2;
  std::array<int,std::max(0,rank2-2)>rate3,invrate3;
  constexpr ntt_root(){
    root[rank2]=pow_mod(g,m>>rank2,m);
    invroot[rank2]=pow_mod(root[rank2],m-2,m);
    for(int i=rank2-1;i>=0;i--){
      root[i]=(long long)root[i+1]*root[i+1]%m;
      invroot[i]=(long long)invroot[i+1]*invroot[i+1]%m;
    }
    int prod=1,invprod=1;
    for(int i=0;i<rank2-1;i++){
      rate2[i]=(long long)root[i+2]*prod%m;
      invrate2[i]=(long long)invroot[i+2]*invprod%m;
      prod=(long long)prod*invroot[i+2]%m;
      invprod=(long long)invprod*root[i+2]%m;
    }
    prod=invprod=1;
    for(int i=0;i<rank2-2;i++){
      rate3[i]=(long long)root[i+3]*prod%m;
      invrate3[i]=(long long)invroot[i+3]*invprod%m;
      prod=(long long)prod*invroot[i+3]%m;
      invprod=(long long)invprod*root[i+3]%m;
    }
  }
};
template<typename T>
void dft(std::vector<T>&a){
  static constexpr ntt_root<T::mod()>r;
  static constexpr unsigned long long mod2=(unsigned long long)T::mod()*T::mod();
  int n=a.size();
  int h=lsb(n);
  int len=0;
  while(len<h){
    if(h-len==1){
      T rot=T::raw(1);
      for(int s=0;s<(1<<len);s++){
        int of=s*2;
        T u=a[of],v=a[of+1]*rot;
        a[of]=u+v;
        a[of+1]=u-v;
        rot*=T::raw(r.rate2[lsb(~(unsigned int)s)]);
      }
      len++;
    }
    else{
      int p=1<<(h-len-2);
      T rot=T::raw(1),imag=T::raw(r.root[2]);
      for(int s=0;s<(1<<len);s++){
        const unsigned long long rot1=rot.val(),rot2=rot1*rot1%T::mod(),rot3=rot1*rot2%T::mod();
        int of=s<<(h-len);
        for(int i=0;i<p;i++){
          const unsigned long long a0=a[i+of].val(),a1=(unsigned long long)a[i+of+p].val()*rot1,a2=(unsigned long long)a[i+of+p*2].val()*rot2,a3=(unsigned long long)a[i+of+p*3].val()*rot3;
          const unsigned long long m=(unsigned long long)T(a1+mod2-a3).val()*imag.val();
          const unsigned long long k=mod2-a2;
          a[i+of]=a0+a2+a1+a3;
          a[i+of+p]=a0+a2+(mod2*2-a1-a3);
          a[i+of+p*2]=a0+k+m;
          a[i+of+p*3]=a0+k+(mod2-m);
        }
        rot*=T::raw(r.rate3[lsb(~(unsigned int)s)]);
      }
      len+=2;
    }
  }
}
template<typename T>
void idft(std::vector<T>&a){
  static constexpr ntt_root<T::mod()>r;
  int n=a.size();
  int h=lsb(n);
  int len=h;
  while(len){
    if(len==1){
      int p=1<<(h-1);
      for(int i=0;i<p;i++){
        T u=a[i],v=a[i+p];
        a[i]=u+v;
        a[i+p]=u-v;
      }
      len--;
    }
    else{
      int p=1<<(h-len);
      T rot=T::raw(1),imag=T::raw(r.invroot[2]);
      for(int s=0;s<(1<<(len-2));s++){
        const unsigned long long rot1=rot.val(),rot2=rot1*rot1%T::mod(),rot3=rot1*rot2%T::mod();
        int of=s<<(h-len+2);
        for(int i=0;i<p;i++){
          const unsigned long long a0=a[i+of].val(),a1=a[i+of+p].val(),a2=a[i+of+p*2].val(),a3=a[i+of+p*3].val();
          const unsigned long long k=T((T::mod()+a2-a3)*imag.val()).val();
          a[i+of]=a0+a1+a2+a3;
          a[i+of+p]=(a0+T::mod()-a1+k)*rot1;
          a[i+of+p*2]=(a0+a1+T::mod()*2-a2-a3)*rot2;
          a[i+of+p*3]=(a0+T::mod()*2-a1-k)*rot3;
        }
        rot*=T::raw(r.invrate3[lsb(~(unsigned int)s)]);
      }
      len-=2;
    }
  }
}
template<typename T>
std::vector<T>ntt_convolution(std::vector<T> a,std::vector<T> b){
  int n=a.size(),m=b.size(),s=n+m-1;
  if(std::min(n,m)<60){
    std::vector<T>ret(s,0);
    if(n<m)for(int i=0;i<m;i++)for(int j=0;j<n;j++)ret[i+j]+=a[j]*b[i];
    else for(int i=0;i<n;i++)for(int j=0;j<m;j++)ret[i+j]+=a[i]*b[j];
    return ret;
  }
  int z=ceil_pow2(s);
  a.resize(z,0);
  b.resize(z,0);
  dft(a),dft(b);
  std::vector<T>c(z);
  for(int i=0;i<z;i++)c[i]=a[i]*b[i];
  idft(c);
  T g=T::raw(z).inv();
  for(int i=0;i<s;i++)c[i]*=g;
  return {c.begin(),c.begin()+s};
}
template<typename T,int p1,int p2,int p3>
T crt3(int a1,int a2,int a3){
  static_assert(p1<p2&&p2<p3);
  static constexpr long long x=pow_mod<int>(p1,p2-2,p2);
  static constexpr long long y=pow_mod<int>((long long)p1*p2%p3,p3-2,p3);
  long long c=(a2-a1+p2)*x%p2;
  long long c2=a1+c*p1;
  c=(a3-c2%p3+p3)*y%p3;
  return T(c2)+T(c)*T(p1)*T(p2);
}
template<typename T>
std::vector<T>anymod_convolution(const std::vector<T>&a,const std::vector<T>&b){
  if(a.empty()||b.empty())return std::vector<T>{};
  if(std::min(a.size(),b.size())<60){
    std::vector<T>ret(a.size()+b.size()-1,0);
    for(int i=0;i<a.size();i++)for(int j=0;j<b.size();j++)ret[i+j]+=a[i]*b[j];
    return ret;
  }
  using mint1=mod_int<167772161>;
  using mint2=mod_int<469762049>;
  using mint3=mod_int<998244353>;
  std::vector<mint1>a1(a.size()),b1(b.size());
  std::vector<mint2>a2(a.size()),b2(b.size());
  std::vector<mint3>a3(a.size()),b3(b.size());
  for(int i=0;i<a.size();i++){
    a1[i]=a[i].val();
    a2[i]=a[i].val();
    a3[i]=a[i].val();
  }
  for(int i=0;i<b.size();i++){
    b1[i]=b[i].val();
    b2[i]=b[i].val();
    b3[i]=b[i].val();
  }
  a1=ntt_convolution(a1,b1),a2=ntt_convolution(a2,b2),a3=ntt_convolution(a3,b3);
  std::vector<T>ret(a.size()+b.size()-1);
  for(int i=0;i<ret.size();i++)ret[i]=crt3<T,mint1::mod(),mint2::mod(),mint3::mod()>(a1[i].val(),a2[i].val(),a3[i].val());
  return ret;
}
template<typename T>
void ntt_doubling(std::vector<T>&a){
  static constexpr ntt_root<T::mod()>r;
  int n=a.size()/2;
  std::vector<T>b(a.begin(),a.begin()+n);
  idft(b);
  T now=T::raw(n).inv(),zeta=T::raw(r.root[msb(n)+1]);
  for(int i=0;i<n;i++){
    b[i]*=now;
    now*=zeta;
  }
  dft(b);
  std::copy(b.begin(),b.end(),a.begin()+n);
}
template<typename T>
T bostan_mori(std::vector<T> p,std::vector<T> q,long long k){
  assert(p.size()<q.size());
  static constexpr ntt_root<T::mod()>r;
  int n=ceil_pow2((int)q.size()*2-1);
  p.resize(n,T::raw(0));
  q.resize(n,T::raw(0));
  dft(p),dft(q);
  T inv2=T::raw(2).inv();
  int n2=n/2;
  while(k){
    for(int i=0;i<n;i++)p[i]*=q[i^1];
    if(k&1){
      T prod=T::raw(1);
      for(int i=0;i<n2;i++){
        p[i]=(p[i*2]-p[i*2+1])*inv2*prod;
        prod*=r.invrate2[lsb(~i)];
      }
    }
    else{
      for(int i=0;i<n2;i++){
        p[i]=(p[i*2]+p[i*2+1])*inv2;
      }
    }
    for(int i=0;i<n2;i++)q[i]=q[i*2]*q[i*2+1];
    ntt_doubling(p),ntt_doubling(q);
    k>>=1;
  }
  idft(p);
  return p[0]/T::raw(n);
}
template<typename T>
std::vector<T> berlekamp_massey(const std::vector<T>&s){
  const int n=s.size();
  vector<T>b,c;
  b.reserve(n+1),c.reserve(n+1);
  b.emplace_back(1),c.emplace_back(1);
  T y=1;
  for(int i=1;i<=n;i++){
    int l=c.size(),m=b.size();
    T x=0;
    for(int j=0;j<l;j++)x+=c[j]*s[i-l+j];
    b.emplace_back(0);
    ++m;
    if(x==0)continue;
    T f=x/y;
    if(l<m){
      auto c2=c;
      c.insert(c.begin(),m-l,0);
      for(int j=0;j<m;j++)c[m-1-j]-=f*b[m-1-j];
      b=c2;
      y=x;
    }
    else{
      for(int j=0;j<m;j++)c[l-1-j]-=f*b[m-1-j];
    }
  }
  std::reverse(c.begin(),c.end());
  return c;
}
template<typename T>
T kth_term(vector<T>p,ll k){
  vector<T>q=berlekamp_massey(p);
  if constexpr(T::mod()==998244353){
    p=ntt_convolution(p,q);
    p.resize(q.size()-1);
    return bostan_mori(p,q,k);
  }
  p=anymod_convolution(p,q);
  int n=q.size();
  p.resize(n-1);
  vector<T>mq(n);
  while(k){
    rep(i,n)mq[i]=q[i]*(i&1?-1:1);
    p=anymod_convolution(p,mq);
    q=anymod_convolution(q,mq);
    vector<T>u(n-1),v(n);
    if(k&1)rep(i,n-1)u[i]=p[i*2+1];
    else rep(i,n-1)u[i]=p[i*2];
    rep(i,n)v[i]=q[i*2];
    swap(p,u),swap(q,v);
    k>>=1;
  }
  if(p.empty())return 0;
  else return p[0];
}
using mint=mint998;
void SOLVE(){
  ll n;
  int m;
  cin>>n>>m;
  vector<int>p{2,3,5,7,11,13};
  vector<vector<int>>div(m+1);
  rep(i,1,m+1){
    div[i].resize(p.size());
    int x=i;
    rep(j,p.size()){
      while(x%p[j]==0){
        x/=p[j];
        div[i][j]++;
      }
    }
  }
  vector<mint>s(100);
  vector<mint>dp(1<<p.size(),1);
  rep(i,100){
    vector<mint>ndp(1<<p.size());
    rep(j,dp.size()){
      rep(k,1,m+1){
        rep(l,dp.size()){
          l|=j;
          int diff=j^l;
          mint coef=1;
          rep(a,p.size())if(diff>>a&1){
            coef*=div[k][a];
          }
          ndp[l]+=dp[j]*coef;
        }
      }
    }
    dp=move(ndp);
    s[i]=dp.back();
    if(i)s[i]+=s[i-1];
  }
  cout<<kth_term(s,n-1)<<endl;
}
