#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
#define int ll

const int N = 1<<18;

struct SegTree {
    int Tree[2*N];

    void update(int u, int val) {
        u += N;
        Tree[u] = val;
        u /= 2;

        while(u > 0) {
            Tree[u] = max(Tree[2*u], Tree[2*u + 1]);
            u /= 2;
        }
    }

    int query(int a, int b) {
        a += N;
        b += N;
        int sol = max(Tree[a], Tree[b]);

        while(a < b - 1) {
            if(a / 2 == (a+1) / 2)
                sol = max(sol, Tree[a+1]);
            if(b / 2 == (b-1) / 2)
                sol = max(sol, Tree[b-1]);

            a /= 2;
            b /= 2;
        }
        return sol;
    }
};

int T[N];

SegTree T1;
unordered_map<int, vector<int>> Positions;

pair<ll, int> Solve(int beg, int end, int limit)
{
    if(end - beg == 1)
        return {0, 0};
    
    int maxi = T1.query(beg + 1, end - 1);
    ll sol = 0;

    int last = end;
    int cnt = 0;
    while(Positions[maxi].size() > 0 && Positions[maxi].back() > beg) {
        pair<int, int> x = Solve(Positions[maxi].back(), last, maxi);
        sol += x.first;
        cnt += x.second;

        last = Positions[maxi].back();
        Positions[maxi].pop_back();
        cnt++;
    }
    pair<int, int> x = Solve(beg, last, maxi);
    sol += x.first;
    cnt += x.second;

    if(limit == -1) {
        while(cnt > 1) {
            if(cnt & 1) {
                sol++;
                cnt++;
            }
            cnt /= 2;
        }
    } else {
        while(maxi < limit && cnt > 1) {
            if(cnt & 1) {
                sol++;
                cnt++;
            }
            cnt /= 2;
            maxi++;
        }

        if(cnt == 1)
            sol += (limit - maxi);
    }
    return {sol, cnt};
}

int32_t main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int t, n;
    cin >> t;

    while(t --> 0) {
        cin >> n;

        for(int i = 1; i <= n; i++) {
            cin >> T[i];

            Positions[T[i]].push_back(i);
            T1.update(i, T[i]);
        }
        cout << Solve(0, n+1, -1).first << "\n";
        Positions.clear();
    }
}