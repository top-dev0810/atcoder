#include "bits/stdc++.h"
using namespace std;

#pragma GCC optimize("O3,unroll-loops")
// #pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")

/* 
find my code templates at https://github.com/galencolin/cp-templates
also maybe subscribe please thanks 
*/

#define send {ios_base::sync_with_stdio(false);}
#define help {cin.tie(NULL);}
#define f first
#define s second
#define getunique(v) {sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());}
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()

typedef long double ld;
typedef unsigned long long ull;

using ll = long long;
// using ll = int;
// #pragma warning("int")
//
using vl = vector<ll>;
using vvl = vector<vl>;
using pl = pair<ll, ll>;
using pd = pair<ld, ld>;

#define F(i, n) for (ll i = 0; i < n; i++)

#include <ext/pb_ds/assoc_container.hpp> 
#include <ext/pb_ds/tree_policy.hpp>
// #include <bits/extc++.h>

using namespace std;
using namespace __gnu_pbds; 

template <typename num_t>
using ordered_set = tree<num_t, null_type, less<num_t>, rb_tree_tag, tree_order_statistics_node_update>;

const string PAIR_LEFT = "(";
const string PAIR_RIGHT = ")";
const string IT_LEFT = "[";
const string IT_RIGHT = "]";
const string PAIR_SEP = ", ";
const string IT_SEP = ", ";

// const string PAIR_LEFT = "(";
// const string PAIR_RIGHT = ")";
// const string IT_LEFT = "[";
// const string IT_RIGHT = "]";
// const string PAIR_SEP = " ";
// const string IT_SEP = " ";

// const string PAIR_LEFT = "{";
// const string PAIR_RIGHT = "}";
// const string IT_LEFT = "{";
// const string IT_RIGHT = "}";
// const string PAIR_SEP = ", ";
// const string IT_SEP = ", ";

// benq - print any container + pair
template<typename T, typename = void> struct is_iterable : false_type {};
template<typename T> struct is_iterable<T, void_t<decltype(begin(declval<T>())),decltype(end(declval<T>()))>> : true_type {};
template<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v);
template<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << PAIR_LEFT << p.f << PAIR_SEP << p.s << PAIR_RIGHT; }
template<typename T> typename enable_if<is_iterable<T>::value&&!is_same<T, string>::value,ostream&>::type operator<<(ostream &cout, T const &v) {
    cout << IT_LEFT; 
    for (auto it = v.begin(); it != v.end();) {
        cout << *it;
        if (++it != v.end()) cout << IT_SEP;
    }
    return cout << IT_RIGHT;
}
template<typename A, typename B> istream& operator>>(istream& cin, pair<A, B> &p) {
    cin >> p.first;
    return cin >> p.second;
}

template<typename T> void debug(string s, T x) {cerr << "\033[1;34m" << s << "\033[0;32m = \033[35m" << x << "\033[0m\n";}
template<typename T, typename... Args> void debug(string s, T x, Args... args) {for (int i=0, b=0; i<(int)s.size(); i++) if (s[i] == '(' || s[i] == '{') b++; else
        if (s[i] == ')' || s[i] == '}') b--; else if (s[i] == ',' && b == 0) {cerr << "\033[1;34m" << s.substr(0, i) << "\033[0;32m = \033[35m" << x << "\033[31m | "; debug(s.substr(s.find_first_not_of(' ', i + 1)), args...); break;}}
template<typename T> void debug_nameless(T x) {cerr << "\033[35m" << x << "\033[0m\n";}
template<typename T, typename... Args> void debug_nameless(T x, Args... args) {cerr << "\033[35m" << x << "\033[31m | "; debug_nameless(args...);}

#ifdef galen_colin_local
#define pr(...) debug(#__VA_ARGS__, __VA_ARGS__)
#define prs(...) debug_nameless(__VA_ARGS__)
const bool local_ = true;
#else
#define pr(...) 135
#define prs(...) 135
const bool local_ = false;
#endif

mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());
// mt19937_64 rng(61378913);
/* usage - just do rng() */

void usaco(string filename) {
// #pragma message("be careful, freopen may be wrong")
    freopen((filename + ".in").c_str(), "r", stdin);
    freopen((filename + ".out").c_str(), "w", stdout);
}

// #include <atcoder/all>
// using namespace atcoder;

// const ld pi = 3.14159265358979323846;
// const ll mod = 1000000007;
const ll mod = 998244353;
// ll mod;

namespace number_theory {
	ll gcd(ll x, ll y) {
	  if (x == 0) return y;
	  if (y == 0) return x;
	  return gcd(y, x % y);
	}
	bool isprime(ll n) { 
	  if (n <= 1) return false; 
	  if (n <= 3) return true; 
	  
	  if (n % 2 == 0 || n % 3 == 0) return false; 
	  
	  for (ll i = 5; i * i <= n; i += 6) 
		if (n % i == 0 || n % (i+2) == 0) 
		  return false; 
	  
	  return true; 
	} 
	 
	bool prime[15000105]; 
	void sieve(int n) { 
	  for (ll i = 0; i <= n; i++) prime[i] = 1;
	  for (ll p = 2; p * p <= n; p++) { 
		if (prime[p] == true) { 
		  for (ll i = p * p; i <= n; i += p) 
			prime[i] = false; 
		} 
	  } 
	  prime[1] = prime[0] = 0;
	} 
	 
	vector<ll> primelist;
	bool __primes_generated__ = 0;
	 
	void genprimes(int n) {
	  __primes_generated__ = 1;
	  sieve(n + 1);
	  for (ll i = 2; i <= n; i++) if (prime[i]) primelist.push_back(i);
	}
	 
	vector<ll> factors(ll n) {
	  if (!__primes_generated__) {
		cerr << "Call genprimes you dope" << endl;
		exit(1);
	  }
	  vector<ll> facs;
	 
	  for (ll i = 0; primelist[i] * primelist[i] <= n && i < primelist.size(); i++) {
		if (n % primelist[i] == 0) {
		  while (n % primelist[i] == 0) {
			n /= primelist[i];
			facs.push_back(primelist[i]);
		  }
		}
	  }
	  if (n > 1) {
		facs.push_back(n);
	  }
	  sort(facs.begin(), facs.end());
	  return facs;
	}
	
	vector<ll> getdivs(ll n) {
    vector<ll> divs;
    for (ll i = 1; i * i <= n; i++) {
      if (n % i == 0) {
        divs.push_back(i);
        divs.push_back(n / i);
      }
    }

    getunique(divs);
    return divs;
  }
}
using namespace number_theory;
namespace modop {
	void add(ll &a, ll b) {
        a += b;
        if (a >= mod) a -= mod;
    }
    void sub(ll &a, ll b) {
        a -= b;
        if (a < 0) a += mod;
    }
	ll mpow(ll base, ll exp) {
	  ll res = 1;
	  while (exp) {
		if (exp % 2 == 1){
			res = (res * base) % mod;
		}
		exp >>= 1;
		base = (base * base) % mod;
	  }
	  return res;
	}
	ll minv(ll base) {
	  return mpow(base, mod - 2);
	}
    inline ll mul(ll x) {
        return x;
    }
    template<typename... Args>
    inline ll mul(ll x, Args... rest) {
        return x * mul(rest...) % mod;
    }
	
	const ll FACTORIAL_SIZE = 2.1e6;
	ll fact[FACTORIAL_SIZE], ifact[FACTORIAL_SIZE];
	bool __factorials_generated__ = 0;
	void gen_factorial(ll n) {
		__factorials_generated__ = 1;
		fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
		
		for (ll i = 2; i <= n; i++) {
			fact[i] = (i * fact[i - 1]) % mod;
		}
		ifact[n] = minv(fact[n]);
		for (ll i = n - 1; i >= 2; i--) {
			ifact[i] = ((i + 1) * ifact[i + 1]) % mod;
		}
	}
	ll nck(ll n, ll k) {
		if (!__factorials_generated__) {
			cerr << "Call gen_factorial you dope" << endl;
			exit(1);
		}
		if (k < 0 || n < k) return 0;
		ll den = (ifact[k] * ifact[n - k]) % mod;
		return (den * fact[n]) % mod;
	}
}
using namespace modop;



ll n, m, q, k, l, r, x, y, z;
vl a, b, c;
string s, t;

namespace sslow {
    set<ll> st;
    ll s;
    vl dc(ll x) {
        vl d(s);
        for (ll i = 0; i < s; i++) d[i] = x % n, x /= n;
        return d;
    }
    ll hs(vl x) {
        ll t = 0, r = 1;
        for (ll i = 0; i < s; i++) t += r * x[i], r *= n;
        return t;
    }
    bool cond(vl v, bool F = 0) {
        if (m > 1) {
            bool pos = 0;
            ll ct = 0;
            set<ll> ca, cb;
            bool fr = 0;
            ll save = 0, eq = -1;
            ll sf = 0;
            vl cc(n);
            vector<vl> cols(n);
            for (ll j = 0; j < n; j++) {
                for (ll i = m - 2; i >= 0; i--) {
                    if (v[1 + i * n + j] == v[1 + (i + 1) * n + j]) ++sf, ++cc[j];
                }
                for (ll i = 0; i < m; i++) {
                    if (cols[j].size() == 0 || v[1 + i * n + j] != cols[j].back()) cols[j].push_back(v[1 + i * n + j]);
                }
                for (ll i = 0; i < m; i++) {
                    if (i + cols[j].size() < m) v[1 + i * n + j] = cols[j][0];
                    else v[1 + i * n + j] = cols[j][i + cols[j].size() - m];
                }
            }
            if (sf >= 3) return 1;
            ll t = 0;
            for (ll x: cc) t += x > 0;
            map<ll, ll> rp, r2;
            cc = vl(n, 0);
            for (ll j = 0; j < n; j++) {
                if (v[1 + j] == v[1 + n + j]) ++ct, eq = v[1 + j], cc[j] = 1;
                ca.insert(v[1 + j]);
                cb.insert(v[1 + n + j]);
                ++rp[v[1 + j]];
                ++r2[v[1 + n + j]];
                if (v[0] == v[1 + j]) fr = 1;
                if (v[0] == v[1 + n + j]) save++;
            }
            ll as = ca.size(), bs = cb.size();
            if (sf == 0) {
                return fr && as < n && (bs >= 2 || as <= n - 2);
            }
            if (sf == 1) {
                if (as == n) return bs >= 2;
                if (as <= n - 2 || fr) return 1;
                ll cp = 0;
                for (ll j = 0; j < n; j++) {
                    if (eq == v[1 + j]) {
                        ++cp;
                        if (v[1 + n + j] == eq) --cp;
                    }
                }
                return cp == 0 && bs >= 2;
            }
            if (sf == 2) {
                if (as != n - 1 || fr) return 1;
                for (ll j = 0; j < n; j++) {
                    if (cc[j] > 0 && rp[v[1 + j]] == 1) return 1;
                }
                if (t == 1) {
                    ll c = 0;
                    for (ll j = 0; j < n; j++) {
                        if (cc[j] > 0 && rp[v[1 + j]] == 2) c = r2[v[1 + j]] - 2;
                    }
                    if (bs >= 3 || (bs == 2 && c == 0)) return 1;
                } else {
                    if (bs >= 2) return 1;
                }
            }
        }
        return 0;
    }
    void dfs(vl v) {
        queue<ll> q;
        q.push(hs(v));
        while (!q.empty()) {
            ll h = q.front();
            q.pop();
            if (st.count(h)) continue;
            st.insert(h);
            if (st.size() % 100000 == 0) pr(st.size());
            vl v = dc(h);
            // bool pos = cond(v);
            // if (!pos) {
            //     pr(v);
            //     assert(pos);
            // }
            for (ll i = 1; i < s; i++) {
                ll t = max(i - n, (ll) 0);
                if (v[i] != v[t]) {
                    vl r = v;
                    r[i] = r[t];
                    q.push(hs(r));
                    r = v;
                    r[t] = r[i];
                    q.push(hs(r));
                }
            }
        }
    }
    bool FR(vl v) {
        bool pos = 0;
        if (m > 1) {
            ll ct = 0;
            set<ll> ca, cb;
            bool fr = 0;
            ll save = 0;
            for (ll j = 0; j < n; j++) {
                if (v[1 + j] == v[1 + n + j]) ++ct;
                ca.insert(v[1 + j]);
                cb.insert(v[1 + n + j]);
                if (v[0] == v[1 + j]) fr = 1;
                if (v[0] == v[1 + n + j]) save++;
            }
            // pos = fr && save == 0;
            return 0;
        }
        
        return pos;
    }
    ll solve() {
        s = n * m + 1;
        vl v(s);
        for (ll i = 0; i < s; i++) {
            v[i] = i == 0 ? 0 : (i - 1) % n;
        }

        st.clear();
        dfs(v);

        map<vl, ll> ct;
        // map<vl, map<vl, vector<vl>>> ct;
        for (ll x: st) {
            vl v = dc(x);
            vl r = v;
            reverse(all(r));
            r.resize(n);
            reverse(all(r));
            // vl r2 = v;
            // r2.resize(2 * n + 1);
            ++ct[r];
            // ct[r][r2].push_back(v);
            bool pos = cond(v);
        }
        ll mx = mpow(n, s);
        ll t = 0;
        for (ll i = 0; i < mx; i++) {
            vl v = dc(i);
            bool pos = cond(v);
            // pr(i, pos, st.count(i), v);
            // assert(pos == st.count(i));
            t += pos;
            // if (pos && !st.count(i)) pr(v), assert(!FR(v));
        }
        // for (auto [x, v]: ct) pr(x, v, mpow(n, n * (m - 1) + 1) - v);
        pr(t);
        // pr(ct);
        // pr(ct[{0, 0, 1, 2}]);
        // for (auto [x, v]: ct[{0, 0, 0, 1}]) pr(x, v.size(), v);

        return st.size();
    }
}

namespace smart {
    ll solve() {
        gen_factorial(n + m);

        if (n == 1) return 1;
        if (n == 2) return 2 * (m + 1);
        if (m == 1) {
            ll tot = mpow(n, n * m + 1);
            sub(tot, mul(n, mpow(n - 1, n)));
            ll f = fact[n];
            sub(f, 1);
            sub(tot, mul(n, f));

            return tot;
        }

        ll tot = mpow(n, n * m + 1);
        ll bad = 0;

        // sf == 0
        {
            ll t = 0;
            add(t, mul(fact[n], mpow(n - 1, n * (m - 1))));
            add(t, mul(mpow(n - 1, n), mpow(n - 1, n * (m - 1))));
            add(t, mul(n - 1, n - 1, nck(n, 2), fact[n - 2], mpow(n - 1, n * (m - 2))));

            t = mul(t, n); // root choice
            add(bad, t);
        }

        // sf == 1
        {
            ll t = 0;
            add(t, mul(fact[n], n, mpow(n - 1, n * (m - 2))));
            {
                ll tt = 0;
                add(tt, mul(2, mpow(n - 1, n * (m - 1) - 1)));
                add(tt, mul(n - 2, mpow(n - 1, n * (m - 2))));

                tt = mul(tt, n - 1, nck(n, 2), fact[n - 2]);
                add(t, tt);
            }

            t = mul(t, m - 1); // sf choice
            t = mul(t, n); // root choice
            add(bad, t);
        }

        // sf == 2
        {
            ll t = 0;

            // t == 1
            if (m > 2) {
                ll tt = 0;
                add(tt, mpow(n - 1, n * (m - 2) - 1));

                tt = mul(tt, 2); // sf col
                tt = mul(tt, nck(m - 1, 2)); // sf choice
                add(t, tt);
            }

            // t == 2
            {
                ll tt = 0;
                add(tt, mpow(n - 1, n * (m - 2)));

                tt = mul(tt, m - 1, m - 1); // sf choice
                add(t, tt);
            }

            t = mul(t, n - 1, nck(n, 2), fact[n - 2]);
            t = mul(t, n); // root choice
            add(bad, t);
        }

        sub(tot, bad);
        return tot;
    }
}

namespace opt {
    void precomp() {
        
    }
    void stress() {
        for (ll it = 0; it < 1e12; it++) {
            

            if (it % 1000 == 0) pr(it);
        }
    }
}
using namespace opt;

const bool run = local_ ? 1 : 1;
const bool TC = 0;
void solve(int tc = 0) {
    cin >> n >> m;

    ll ans = smart::solve();
    cout << ans << endl;

    if (local_) {
        ll jur = sslow::solve();
        pr(jur);
    }
}

int main() {
    #ifdef galen_colin_local
        auto begin = std::chrono::high_resolution_clock::now();
    #endif
    
    send help

    #ifndef galen_colin_local
        // usaco("cbs");
    #endif
    
    // usaco("cowland");
    
    // freopen("tc.txt", "r", stdin);
    // freopen("tc.txt", "w", stdout);
    // freopen("tc2.cpp", "w", stdout);
    // freopen("in.txt", "r", stdin);
    // freopen("out.txt", "w", stdout);

    cout << setprecision(15) << fixed;
    cerr << setprecision(4) << fixed;

    

    precomp();

    if (!run) {
        stress();
        return 0;
    }

    int tc = 1;
    // if (local_)
    // if (run)
    if (TC) cin >> tc;
    for (int t = 0; t < tc; t++) {
        pr(t); prs(string(50, '-'));
        solve(t);
        prs(string(50, '-') + "\n");
    }
    
    #ifdef galen_colin_local
        auto end = std::chrono::high_resolution_clock::now();
        cerr << setprecision(4) << fixed;
        cerr << "Execution time: " << std::chrono::duration_cast<std::chrono::duration<double>>(end - begin).count() << " seconds" << endl;
    #endif
}